{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"craftable \u2014 craft elegant terminal tables using format strings","text":"<p>Generate clean, flexible text tables in the terminal or in text files using a familiar, Python-native formatting approach. craftable focuses on attractive and predictable output, zero dependencies, a simple and elegant API, and fast rendering without requiring a full TUI library.</p> <ul> <li>Small, zero-dependency API</li> <li>Works with plain Python data (lists/rows)</li> <li>Column definitions use Python\u2019s format mini-language</li> <li>Multiple built-in styles: no borders, box drawing, rounded, ASCII, Markdown</li> <li>Supports wrapping, truncation, alignment, and auto-fill columns</li> <li>Simple, but flexible and extensible to meet most any use case</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>from craftable import get_table\n\ndata = [\n    [\"Alice\", 147000, .035, \"Engineer\"],\n    [\"Bob\", 88000, .0433, \"Designer\"],\n]\n\nprint(get_table(\n    data,\n    header_row=[\"Name\", \"Salary\", \"Adj\", \"Title\"],\n    col_defs=[\"A\",\"&lt;$ (,)\", \"&gt;.2%\", \"A\"],\n    table_width=50,\n))\n</code></pre> <p>Output:</p> <pre><code>      Name     \u2502   Salary  \u2502  Adj  \u2502    Title     \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Alice         \u2502 $ 147,000 \u2502 3.50% \u2502 Engineer     \n Bob           \u2502 $  88,000 \u2502 4.33% \u2502 Designer     \n</code></pre>"},{"location":"#what-youll-find-in-this-guide","title":"What you\u2019ll find in this guide","text":"<ul> <li>Getting Started: install and first table</li> <li>Usage Guide: headers, widths, wrapping, truncation, alignment</li> <li>Formatting Guide: column definitions and flags</li> <li>Styles: pick a look (box, rounded, markdown, no border)</li> <li>API Reference: full docs for public functions and classes</li> </ul>"},{"location":"#when-to-use-craftable","title":"When to use craftable","text":"<p>Use craftable when you need reliable text tables in logs, CLIs, or scripts, and want the control of Python format specs without heavy UI tooling. If you need interactive widgets or color/styling, consider pairing with Rich \u2014 but for static tables, craftable is intentionally simple and fast.</p>"},{"location":"adapters/","title":"Data Adapters","text":"<p>Craftable includes a comprehensive set of adapters to convert various Python data structures into table format. All adapters return a tuple of <code>(rows, headers)</code> that can be directly used with <code>get_table()</code>.</p>"},{"location":"adapters/#overview","title":"Overview","text":"<p>Each adapter function follows a consistent pattern:</p> <ul> <li>Returns: <code>tuple[list[list[Any]], list[str]]</code> - (value rows, header row)</li> <li>Tolerates missing/ragged data - fills gaps with <code>None</code></li> <li>Supports optional column filtering via <code>columns</code> parameter</li> <li>Zero dependencies for core adapters (numpy/pandas optional)</li> </ul>"},{"location":"adapters/#available-adapters","title":"Available Adapters","text":""},{"location":"adapters/#from_dicts","title":"<code>from_dicts()</code>","text":"<p>Convert a list of dictionaries to table format. Ideal for JSON-like data or API responses.</p> <p>Features: - Automatically discovers all keys across all dictionaries - Tolerates missing keys (fills with <code>None</code>) - Supports column ordering: <code>\"detect\"</code> (default) or <code>\"alpha\"</code> - Optional <code>first_only</code> mode to ignore keys beyond first dict</p> <pre><code>from craftable import get_table\nfrom craftable.adapters import from_dicts\n\ndata = [\n    {\"name\": \"Alice\", \"age\": 30, \"city\": \"LA\"},\n    {\"name\": \"Bob\", \"age\": 25},  # Missing 'city'\n    {\"name\": \"Charlie\", \"city\": \"NYC\"}  # Missing 'age'\n]\n\nrows, headers = from_dicts(data)\nprint(get_table(rows, header_row=headers))\n</code></pre> <p>Output: <pre><code>   name  \u2502 age  \u2502 city \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\n Alice   \u2502 30   \u2502 LA   \n Bob     \u2502 25   \u2502 None \n Charlie \u2502 None \u2502 NYC  \n</code></pre></p> <p>Column Filtering: <pre><code># Only show specific columns\nrows, headers = from_dicts(data, columns=[\"name\", \"city\"])\nprint(get_table(rows, header_row=headers))\n</code></pre></p> <p>Column Ordering: <pre><code># Order alphabetically\nrows, headers = from_dicts(data, order=\"alpha\")\n\n# Use only keys from first dict (ignore \"city\" from Charlie)\nrows, headers = from_dicts(data, first_only=True)\n# headers: [\"name\", \"age\"]\n\n# Combine: first dict keys only, sorted alphabetically\nrows, headers = from_dicts(data, first_only=True, order=\"alpha\")\n</code></pre></p>"},{"location":"adapters/#from_mapping_of_lists","title":"<code>from_mapping_of_lists()</code>","text":"<p>Convert a dictionary-of-lists (columnar format) to table format. Common with pandas-style data.</p> <p>Features: - Handles ragged columns (different lengths) by padding with <code>None</code> - Preserves insertion order of keys (Python 3.7+)</p> <pre><code>from craftable import get_table\nfrom craftable.adapters import from_mapping_of_lists\n\ndata = {\n    \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n    \"score\": [95, 87, 92],\n    \"grade\": [\"A\", \"B\", \"A\"]\n}\n\nrows, headers = from_mapping_of_lists(data)\nprint(get_table(rows, header_row=headers))\n</code></pre> <p>Output: <pre><code>   name  \u2502 score \u2502 grade \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Alice   \u2502 95    \u2502 A     \n Bob     \u2502 87    \u2502 B     \n Charlie \u2502 92    \u2502 A     \n</code></pre></p> <p>Ragged Columns: <pre><code>ragged = {\n    \"name\": [\"Alice\", \"Bob\"],\n    \"score\": [95, 87, 92]  # Extra value\n}\nrows, headers = from_mapping_of_lists(ragged)\n# Row 3: [None, 92]\n</code></pre></p>"},{"location":"adapters/#from_dataclasses","title":"<code>from_dataclasses()</code>","text":"<p>Convert dataclass instances to table format. Type-safe alternative to dictionaries.</p> <p>Features: - Automatically extracts field names - Excludes private fields (starting with <code>_</code>) by default - Supports column filtering</p> <pre><code>from dataclasses import dataclass\nfrom craftable import get_table\nfrom craftable.adapters import from_dataclasses\n\n@dataclass\nclass Employee:\n    name: str\n    age: int\n    department: str\n    salary: float\n\nemployees = [\n    Employee(\"Alice\", 30, \"Engineering\", 95000),\n    Employee(\"Bob\", 25, \"Marketing\", 75000),\n]\n\nrows, headers = from_dataclasses(employees)\nprint(get_table(rows, header_row=headers))\n</code></pre> <p>Output: <pre><code>  name \u2502 age \u2502  department \u2502  salary \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Alice \u2502 30  \u2502 Engineering \u2502 95000.0 \n Bob   \u2502 25  \u2502 Marketing   \u2502 75000.0 \n</code></pre></p> <p>Private Fields: <pre><code>@dataclass\nclass Record:\n    name: str\n    _internal_id: int  # Excluded by default\n\n# Include private fields\nrows, headers = from_dataclasses(data, include_private=True)\n</code></pre></p>"},{"location":"adapters/#from_models","title":"<code>from_models()</code>","text":"<p>Generic adapter for model instances (Pydantic, attrs, dataclasses, or plain objects).</p> <p>Features: - Auto-detects model type and uses appropriate conversion - Supports Pydantic v1 (<code>dict()</code>) and v2 (<code>model_dump()</code>) - Falls back to <code>__dict__</code> for plain classes</p> <pre><code>from craftable import get_table\nfrom craftable.adapters import from_models\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\npeople = [Person(\"Alice\", 30), Person(\"Bob\", 25)]\nrows, headers = from_models(people)\nprint(get_table(rows, header_row=headers))\n</code></pre> <p>Works with Pydantic: <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    username: str\n    email: str\n\nusers = [User(username=\"alice\", email=\"alice@example.com\")]\nrows, headers = from_models(users)\n</code></pre></p>"},{"location":"adapters/#from_records","title":"<code>from_records()</code>","text":"<p>Convert an iterable of tuples/lists to table format with optional headers.</p> <p>Features: - Simple conversion for raw record data - Auto-generates headers (<code>col_0</code>, <code>col_1</code>, ...) if not provided</p> <pre><code>from craftable import get_table\nfrom craftable.adapters import from_records\n\ndata = [\n    (\"Alice\", 30, \"LA\"),\n    (\"Bob\", 25, \"NYC\")\n]\n\nrows, headers = from_records(data, columns=[\"name\", \"age\", \"city\"])\nprint(get_table(rows, header_row=headers))\n</code></pre> <p>Output: <pre><code>  name \u2502 age \u2502 city \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\n Alice \u2502 30  \u2502 LA   \n Bob   \u2502 25  \u2502 NYC  \n</code></pre></p> <p>Auto-generated Headers: <pre><code>rows, headers = from_records(data)\n# headers: [\"col_0\", \"col_1\", \"col_2\"]\n</code></pre></p>"},{"location":"adapters/#from_sql","title":"<code>from_sql()</code>","text":"<p>Convert database query results to table format. Works with DB-API cursors.</p> <p>Features: - Auto-detects column names from cursor description - Works with raw rows + description - Falls back to generic headers if no description</p> <pre><code>from craftable import get_table\nfrom craftable.adapters import from_sql\n\n# Using a cursor directly\ncursor.execute(\"SELECT name, age, city FROM users\")\nrows, headers = from_sql(cursor)\nprint(get_table(rows, header_row=headers))\n\n# Using rows + description\ncursor.execute(\"SELECT * FROM products\")\nresult_rows = cursor.fetchall()\nrows, headers = from_sql(result_rows, description=cursor.description)\n</code></pre> <p>Column Filtering: <pre><code># Only show specific columns\nrows, headers = from_sql(cursor, columns=[\"name\", \"email\"])\n</code></pre></p>"},{"location":"adapters/#from_numpy","title":"<code>from_numpy()</code>","text":"<p>Convert NumPy arrays to table format. Requires <code>numpy</code> to be installed.</p> <p>Features: - Supports 1D and 2D arrays - Handles structured arrays (uses field names as headers) - Optional index column</p> <pre><code>import numpy as np\nfrom craftable import get_table\nfrom craftable.adapters import from_numpy\n\n# 2D array\narr = np.array([[1, 2, 3], [4, 5, 6]])\nrows, headers = from_numpy(arr)\n# headers: [\"0\", \"1\", \"2\"]\n\n# 1D array\narr = np.array([10, 20, 30])\nrows, headers = from_numpy(arr)\n# headers: [\"value\"]\n\n# With index column\nrows, headers = from_numpy(arr, include_index=True)\n# headers: [\"index\", \"value\"]\n</code></pre> <p>Structured Arrays: <pre><code>dtype = [('name', 'U10'), ('age', 'i4')]\narr = np.array([('Alice', 30), ('Bob', 25)], dtype=dtype)\nrows, headers = from_numpy(arr)\n# headers: [\"name\", \"age\"]\n</code></pre></p>"},{"location":"adapters/#from_dataframe","title":"<code>from_dataframe()</code>","text":"<p>Convert Pandas or Polars DataFrames to table format. Requires respective library.</p> <p>Features: - Auto-detects Pandas vs Polars - Optional index column - Column filtering support</p> <pre><code>import pandas as pd\nfrom craftable import get_table\nfrom craftable.adapters import from_dataframe\n\ndf = pd.DataFrame({\n    \"name\": [\"Alice\", \"Bob\"],\n    \"score\": [95, 87]\n})\n\nrows, headers = from_dataframe(df)\nprint(get_table(rows, header_row=headers))\n</code></pre> <p>Output: <pre><code>  name \u2502 score \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Alice \u2502 95    \n Bob   \u2502 87    \n</code></pre></p> <p>With Index: <pre><code>rows, headers = from_dataframe(df, include_index=True)\n# Adds first column with index values\n</code></pre></p> <p>Column Filtering: <pre><code>rows, headers = from_dataframe(df, columns=[\"name\"])\n</code></pre></p>"},{"location":"adapters/#common-patterns","title":"Common Patterns","text":""},{"location":"adapters/#combining-with-custom-formatting","title":"Combining with Custom Formatting","text":"<p>Adapters return raw data - use <code>get_table()</code> parameters for formatting:</p> <pre><code>data = [\n    {\"product\": \"Widget A\", \"price\": 19.99, \"stock\": 150},\n    {\"product\": \"Widget B\", \"price\": 29.99, \"stock\": 75},\n]\n\nrows, headers = from_dicts(data)\n\ntable = get_table(\n    rows,\n    header_row=headers,\n    col_defs=[\n        \"product:20\",     # Fixed width\n        \"price:&gt;8.2f\",    # Right-aligned, 2 decimals\n        \"stock:&gt;6d\"       # Right-aligned integer\n    ]\n)\n</code></pre>"},{"location":"adapters/#filtering-and-transforming","title":"Filtering and Transforming","text":"<pre><code># Filter at adapter level\nrows, headers = from_dicts(data, columns=[\"name\", \"score\"])\n\n# Or filter with ColDef\nrows, headers = from_dicts(data)\ntable = get_table(rows, header_row=headers, col_defs=[\"name\", \"score\"])\n</code></pre>"},{"location":"adapters/#handling-none-values","title":"Handling None Values","text":"<p>All adapters use <code>None</code> for missing values. You have two ways to customize the display:</p> <p>1) Quick, global replacement per table</p> <pre><code>from craftable import get_table\n\ntable = get_table(rows, header_row=headers, none_text=\"(missing)\")\n</code></pre> <p>2) Per\u2011column replacement using <code>ColDef.none_text</code></p> <pre><code>from craftable import get_table\nfrom craftable import ColDefList\n\nspecs = [\"name\", \"age\"]\ncol_defs = ColDefList.parse(specs)  # convenience parser\ncol_defs[0].none_text = \"N/A\"       # only for the first column\ncol_defs[1].none_text = \"--\"        # different placeholder for age\n\ntable = get_table(rows, header_row=headers, col_defs=col_defs)\n</code></pre> <p>Notes: - Per\u2011column <code>none_text</code> overrides the global <code>none_text</code> parameter when both are provided. - <code>none_text</code> is treated as normal text for width/truncation/wrapping.</p>"},{"location":"adapters/#error-handling","title":"Error Handling","text":"<p>Adapters validate input and raise appropriate errors:</p> <ul> <li><code>TypeError</code> - Wrong data type (e.g., non-dataclass passed to <code>from_dataclasses()</code>)</li> <li><code>ImportError</code> - Missing optional dependency (numpy/pandas)</li> <li><code>ValueError</code> - Invalid data shape (e.g., 3D numpy array)</li> </ul> <pre><code>try:\n    rows, headers = from_numpy(array)\nexcept ImportError:\n    print(\"NumPy not installed\")\nexcept ValueError as e:\n    print(f\"Invalid array shape: {e}\")\n</code></pre>"},{"location":"adapters/#performance-notes","title":"Performance Notes","text":"<ul> <li>from_dicts() - Iterates all dicts to find headers (O(n*m) where m = avg   keys)</li> <li>from_mapping_of_lists() - Most efficient for columnar data (O(n))</li> <li>from_dataclasses() - Uses <code>fields()</code> introspection (O(1) per type)</li> <li>from_numpy()/from_dataframe() - Delegates to library's <code>.tolist()</code> methods</li> </ul> <p>Craftable strives to optimize for speed and efficiency, but it necessarily must load multiple copies of a dataset into memory in order to generate a large table. For extremely large datasets (&gt;100K rows), consider:</p> <ol> <li>Column filtering</li> <li>Pagination</li> <li>Using native library display methods</li> </ol>"},{"location":"adapters/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic usage</li> <li>Formatting Guide - Column definitions and styling</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"formatting/","title":"Formatting Guide","text":"<p>craftable embraces Python's format specification mini-language to format columns and values within each cell. Additional directives are added to enhance the formatting capabilities.</p>"},{"location":"formatting/#format-specification-strings","title":"Format Specification Strings","text":"<p>Column definitions are passed as a list of column definitions are strings that combine:</p> <ul> <li>Width and Alignment: same as Python (<code>&lt;</code>, <code>&gt;</code>, <code>^</code>)</li> <li>Type and Precision: same as Python (e.g., <code>.2f</code>, <code>.0%</code>, <code>d</code>)</li> <li>Table Flags: <code>A</code> (auto-fill), <code>T</code> (truncate), <code>S</code> (strict)</li> <li>Prefix and Suffix: Add text before or after each cell value</li> </ul> <p>Standard pattern: <code>[[fill]align][sign][z|#|0][width][grouping][.precision][type]</code></p> <p>Expanded pattern: <code>[prefix_align][prefix](&lt;pattern&gt;[flags])[suffix_align][suffix]</code></p> <p>Examples:</p> <ul> <li><code>\"20\"</code> \u2014 minimum 20 characters (left-align by default)</li> <li><code>\"&gt;10.2f\"</code> \u2014 right-align, 10 chars wide, 2 decimal float</li> <li><code>\"20T\"</code> \u2014 20 chars, truncate with ellipsis</li> <li><code>\"^A\"</code> \u2014 center-align, auto-fill to table width</li> <li><code>\"$ (8.0f)\"</code> - round a float to an int and prefix with \"<code>$</code>\"</li> </ul> <p>For the most part, this will work as expected with any valid format specification. Continue reading below for details and examples.</p> <p>Note</p> <p>Format strings are converted internally to <code>ColDef</code> objects for processing. You should generally use string specifications in your code, unless you wish to pre-parse the strings into <code>ColDef</code> and <code>ColDefList</code> objects and cache them for performance purposes. See the API reference for implementation details.</p>"},{"location":"formatting/#alignment","title":"Alignment","text":"<p>The behavior is identical to standard Python format specifiers. The <code>align</code> character can be one of:</p> <ul> <li><code>&lt;</code> left-align (default for most values)</li> <li><code>&gt;</code> right-align (default for numbers)</li> <li><code>^</code> center-align</li> </ul> <p>Note</p> <p>Unless the \"<code>S</code>\" (strict) flag is added, if an exception is thrown when formatting a value, it is converted to a string and is thus left-aligned. This may cause some confusion if you find some of your numbers being left-aligned. Thus it is recommended to specify \"<code>&gt;</code>\" for columns that you with to ensure are right-aligned.</p>"},{"location":"formatting/#width","title":"Width","text":"<p>If provided, width can deviate somewhat from the expected behavior in Python format specifiers. By default, craftable interprets it to be the exact width of the content of the column, while f-strings consider this to be a minimum width. Consider the following:</p> <pre><code>from math import pi\n\nprint(\"f-string:\")\nprint(f\"{pi:5} | {3.1:5}\")\nprint(\"craftable:\")\nprint(get_table([[pi, 3.1]], col_defs=[\"5\",\"5\"]))\n</code></pre> <p>The output is:</p> <pre><code>f-string:\n3.141592653589793 |   3.1\ncraftable:\n 3.141 \u2502 3.1\n 59265 \u2502\n 35897 \u2502\n 93    \u2502\n</code></pre> <p>Also note that if a prefix and/or suffix are supplied, the <code>width</code> is inclusive of them. This is because the width is assumed to be the width of the cell. So in the example above, <code>\"$ (8.0f)\"</code> would in essence be rendered as <code>f\"$ {val:6.0f}\"</code>, subtracting two from the width to account for the dollar+space prefix.</p> <p>If width is omitted, then the column size will be the lower of:</p> <ul> <li>maximum width of the header and data values (inclusive of prefix/suffix) for     the cloumn</li> <li>the maximum width possible constrained by a specified table_size and      the required width of all other columns</li> </ul> <p>Note</p> <p>See below for column width implications when specifying the <code>A</code> table flag.</p>"},{"location":"formatting/#precision-and-type","title":"Precision and Type","text":"<p>Use standard Python format specifiers. For example:</p> <pre><code>col_defs = [\"10\", \".2f\"]   # float with 2 decimals\ncol_defs = [\"10\", \".0%\"]   # percentage with 0 decimals\ncol_defs = [\"10\", \"d\"]     # integer decimal\n</code></pre> <p>Example with output:</p> <pre><code>rows = [[123.456, 0.789], [7.5, 0.012]]\ncol_defs = [\"&gt;.2f\", \"&gt;.1%\"]\nprint(get_table(rows, header_row=[\"Value\", \"Percent\"], col_defs=col_defs))\n</code></pre> <p>Output:</p> <pre><code>  Value  \u2502 Percent \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  123.46 \u2502   78.9% \n    7.50 \u2502    1.2% \n</code></pre> <p>In practice, the most common types are:</p> <ul> <li><code>s</code> or none for strings (no conversion)</li> <li><code>f</code> to display a number as float</li> <li><code>e</code> to display a number in scientific notation</li> <li><code>%</code> to display a number as a percent</li> </ul> <p>Reference the language specifications for full details on precision and type options.</p>"},{"location":"formatting/#other-format-specifier-options","title":"Other Format Specifier Options","text":"<p>The rest of the standard Python format specifiers are supported, including:</p> <ul> <li><code>fill</code> \u2014 a character used to pad the space to the left of a right-aligned   value or the right of a left-aligned value. Note that this will be between the   value and the prefix/suffix if either is specified.</li> <li><code>sign</code> \u2014 controls the way positive and negative numbers are rendered. <code>+</code>   forces a sign (<code>+</code> or <code>-</code>) to prefix all numbers. <code>-</code> or none to append a sign   only to negative numbers.</li> <li>z|#|0 \u2014 <code>z</code>, <code>#</code> and <code>0</code> further refine the way values are rendered.</li> <li><code>grouping</code> - add <code>,</code> or <code>_</code> to apply thousands separation for large numbers.</li> </ul> <p>Consult the language specifications for additional details and options.</p>"},{"location":"formatting/#additional-table-flags","title":"Additional Table Flags","text":"<p>Craftable allows for three additional flags to be appended to the format string to further refine the formatting behavior when text is rendered into table cells. Append flags to the end of a column spec string (after type/precision):</p>"},{"location":"formatting/#a-auto-fill","title":"A \u2014 Auto-fill","text":"<p>Expands the column to fill remaining available table_width after taking into account the width of all other columns.</p> <p>Note</p> <p>For all \"terminal\" styles (i.e., all except for MarkdownTableStyle), when any column defs have an <code>A</code> attribute, table_width will default to the width of the terminal window.</p> <p>For example:</p> <pre><code>from craftable import get_table\nfrom craftable.styles import BasicScreenStyle\n\nrows = [[\"Alice\", \"Engineer\", \"30\"], [\"Bob\", \"Designer\", \"25\"]]\ncol_defs = [\"A\", \"&lt;10\", \"&lt;5\"]  # first column auto-expands\nprint(get_table(rows, col_defs=col_defs, table_width=60, style=BasicScreenStyle()))\n</code></pre> <p>Output:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Alice                               \u2502 Engineer   \u2502 30    \u2502\n\u2502 Bob                                 \u2502 Designer   \u2502 25    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple auto-fill columns: When multiple columns have <code>A</code>, remaining space is divided evenly:</p> <pre><code>rows = [[\"Alice\", \"Engineer\", \"30\"], [\"Bob\", \"Designer\", \"25\"]]\ncol_defs = [\"A\", \"^A\", \"&lt;5\"]  # first two share expansion\nprint(get_table(rows, col_defs=col_defs, table_width=60, style=BasicScreenStyle()))\n</code></pre> <p>Output (both auto-fill columns get equal extra space):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Alice                   \u2502        Engineer        \u2502 30    \u2502\n\u2502 Bob                     \u2502        Designer        \u2502 25    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"formatting/#t-truncate","title":"T \u2014 Truncate","text":"<p>Cuts off long text and appends an ellipsis (<code>\u2026</code>):</p> <pre><code>rows = [[\"This is a very long sentence that should be truncated\", \"OK\"]]\ncol_defs = [\"20T\", \"5\"]\nprint(get_table(rows, col_defs=col_defs))\n</code></pre> <p>Output:</p> <pre><code> This is a very long\u2026 \u2502 OK    \n</code></pre> <p>The default behavior is to wrap long lines. So the above with simply <code>&lt;20</code> as the first column definition would appear as follows:</p> <pre><code> This is a very long  \u2502 OK    \n sentence that should \u2502       \n be truncated         \u2502       \n</code></pre>"},{"location":"formatting/#s-strict","title":"S \u2014 Strict","text":"<p>If specified, values that cannot be formatted using the supplied format string will raise an exception. By default these values fall back to a simple string conversion.</p>"},{"location":"formatting/#combining-flags","title":"Combining flags","text":"<p>You can combine flags:</p> <pre><code>col_defs = [\"^AT\"]  # centered,auto-fill,truncate\n</code></pre> <p>These are simply additional flags added at the end of a standard string format specification, so you can automatically size columns to fit rounded numbers, etc.</p> <pre><code>col_defs = [\"&gt;.2fAS\"]  # right-aligned,float rounded to 2 decimals,auto-fill, strict\n</code></pre>"},{"location":"formatting/#prefix-and-suffix","title":"Prefix and Suffix","text":"<p>Values provided here will be appended to the start and end of each cell value, respectively.</p> <p>The prefix_align value can be <code>&lt;</code> (left) or <code>&gt;</code> (right, default). This determines if the prefix is left-aligned in the cell or if it will simply be prepended to the value.</p> <p>The suffix_align value can be <code>&lt;</code> (left, default) or <code>&gt;</code> (right). This determines if the suffix is right-aligned in the cell or if it will simply be append to the value.</p> <p>To add a prefix or suffix, simply enclose the format string in parentheses. Any text before the opening paren will be the prefix. Any text after the closing paren will be the suffix. If provided, the prefix_align value must be the very first character of the column definition, and the suffix_align character must be the first character after the closing paren.</p> <p>Note</p> <p>Left aligning a prefix is usually only valuable if the cell is right aligned. Likewise right_aligning suffixes is only valuable for left aligned values.</p> <p>Example:</p> <pre><code>data = [\n    [\"Apple\", 1.99, 12, ],\n    [\"Banana\", 1.49, 10, ],\n    [\"Egg\", 13.99, 2, ],\n]\n\nprint(get_table(\n    data,\n    header_row=[\"Product\", \"Price\", \"Weight\"],\n    col_defs=[\"A\",\"&lt;$ (&gt;8.2f)\", \"(^8) oz\"],\n    table_width=40,\n    style=RoundedBorderScreenStyle(),\n))\n</code></pre> <p>Results:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502    Product     \u2502  Price   \u2502  Weight  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Apple          \u2502 $   1.99 \u2502  12 oz   \u2502\n\u2502 Banana         \u2502 $   1.49 \u2502  10 oz   \u2502\n\u2502 Egg            \u2502 $  13.99 \u2502   2 oz   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"formatting/#header-definitions","title":"Header Definitions","text":"<p>Header alignment can be controlled separately via <code>header_defs</code>. These will accept all of the components of a column definition, however, only alignment (<code>&lt;</code>, <code>^</code>, or <code>&gt;</code>) has any effect.</p> <p>Example:</p> <pre><code>from craftable import get_table\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(\n    rows,\n    header_row=[\"Name\", \"Age\"],\n    col_defs=[\"&lt;10\", \"&gt;5\"],     # data columns: left, right\n    header_defs=[\"^\", \"&gt;\"],  # headers: center, right\n))\n</code></pre> <p>This centers \"Name\" while left-aligning the data below it.</p> <p>If no header_defs are provided, the headers will be centered.</p>"},{"location":"formatting/#preprocessors-and-postprocessors","title":"Preprocessors and Postprocessors","text":"<p>Use per-column callbacks to transform values before formatting (preprocessors) and decorate formatted text (postprocessors). These callbacks are stored on each <code>ColDef</code> internally; preprocessing affects width calculations, postprocessing does not.</p> <p>Definitions:</p> <ul> <li> <p>Preprocessor: <code>fn(value) -&gt; value</code></p> </li> <li> <p>Postprocessor: <code>fn(original_value, text) -&gt; str</code></p> </li> </ul> <p>Example:</p> <pre><code>from craftable import get_table\nfrom rich.console import Console\n\ndef fmt_date(value):\n    if isinstance(value, date):\n        try:\n            return value.strftime(\"%a %b %d, %Y\")\n        except Exception as e:\n            print(f\"Error formatting date: {e}\")\n    return value\n\ndef fmt_currency(original, text):\n    try:\n        value = float(original)\n        if value &lt; 0:\n            return f\"[red]{text}[/red]\"\n    except Exception:\n        pass\n    return text\n\ndata = [\n    [ \"Lowe's\", -54.25, date(2025, 6, 15) ],\n    [ \"Walmart\", -62.83, date(2025, 6, 17) ],\n    [ \"Petsmart\", -35.4, datetime(2025, 6, 17) ],\n    [ \"Deposit\", 1500.0, date(2025, 6, 18) ],\n]\n\nconsole = Console()\nconsole.print(get_table(\n    data,\n    header_row = [ \"Transaction\", \"Amount\", \"Date\" ],\n    col_defs = [ \"&lt;A\", \"&lt;$ (&gt;10.2f)\", \"&lt;\" ],\n    preprocessors = [ None, None, fmt_date ],\n    postprocessors = [ None, fmt_currency, None ],\n    style=RoundedBorderScreenStyle(),\n    table_width=60,\n))\n</code></pre> <p>Output:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502       Transaction       \u2502   Amount   \u2502       Date       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Lowe's                  \u2502 $   -54.25 \u2502 Sun Jun 15, 2025 \u2502\n\u2502 Walmart                 \u2502 $   -62.83 \u2502 Tue Jun 17, 2025 \u2502\n\u2502 Petsmart                \u2502 $   -35.40 \u2502 Tue Jun 17, 2025 \u2502\n\u2502 Deposit                 \u2502 $  1500.00 \u2502 Wed Jun 18, 2025 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Note</p> <p>Though not visible here, all negative values are red in the terminal.</p> <p>Guidelines:</p> <ul> <li>Use <code>None</code> for columns without a callback.</li> <li>Shorter lists are fine; unmatched columns are ignored.</li> <li>Exceptions in callbacks are caught (unless strict formatting already raises).</li> <li>Postprocessors shouldn't alter visible width; avoid padding changes.</li> </ul>"},{"location":"formatting/#common-format-strings","title":"Common Format Strings","text":"<p>The following are common formatting types, their characteristics, and their uses, as well as an example format string that can be used to render them (if possible).</p>"},{"location":"formatting/#currency-2f","title":"Currency: <code>$ (,.2f)</code>","text":"<p>Displays monetary values with commas for thousands separators and two decimal places. Negative numbers display with minus sign by default. Replace <code>$</code> with localized currency symbol as appropriate. Use with or without the space between the symbol and the left paren.</p>"},{"location":"formatting/#aligned-currency-2f","title":"Aligned Currency: <code>&lt;$(,.2f)</code>","text":"<p>Same as above but left-align the currency symbol.</p>"},{"location":"formatting/#percentage-1-or-0","title":"Percentage: <code>.1%</code> or <code>.0%</code>","text":"<p>Displays numbers as a percentage by multiplying the value by 100 and adding a percent sign (e.g., 0.15 becomes 15.0%).</p>"},{"location":"formatting/#scientific-2e","title":"Scientific: <code>.2e</code>","text":"<p>Displays numbers in exponential notation, useful for very large or very small numbers (e.g., 23976986 becomes 2.40e+07).</p>"},{"location":"formatting/#standard-0f","title":"Standard: <code>,.0f</code>","text":"<p>Displays numbers with commas as thousands separators and no decimal places. Handles negative numbers with minus sign.</p>"},{"location":"formatting/#accounting-postprocess","title":"Accounting: postprocess","text":"<p>Similar to currency but follows accounting conventions. Use a postprocessor to display negative numbers in parentheses and format consistently.</p> <p>See the accounting ledger recipe for an example of how to use postprocessing to format numbers using accounting standards.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This page helps you install craftable and print your first table.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>craftable is published on PyPI. Install with your preferred package manager:</p> pippoetryuv <pre><code>pip install craftable\n</code></pre> <pre><code>poetry add craftable\n</code></pre> <pre><code>uv add craftable\n</code></pre> <p>Or if using uv pip: <pre><code>uv pip install craftable\n</code></pre></p>"},{"location":"getting-started/#your-first-table","title":"Your First Table","text":"<pre><code>from craftable import get_table\n\nrows = [\n    [\"Alice\", 30, \"Engineer\"],\n    [\"Bob\", 25, \"Designer\"],\n]\n\nprint(get_table(rows))\n</code></pre> <p>Output:</p> <pre><code> Alice  \u2502 30  \u2502 Engineer \n Bob    \u2502 25  \u2502 Designer \n</code></pre>"},{"location":"getting-started/#spicing-it-up","title":"Spicing it Up","text":"<p>Add a <code>header_row</code> and try a different look with the <code>style</code> parameter:</p> <pre><code>from craftable import get_table\nfrom craftable.styles import BasicScreenStyle\n\nrows = [\n    [\"Alice\", 30, \"Engineer\"],\n    [\"Bob\", 25, \"Designer\"],\n]\n\nprint(get_table(\n    rows,\n    header_row=[\"Name\", \"Age\", \"Title\"],\n    style=BasicScreenStyle()\n))\n</code></pre> <p>Output:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Name  \u2502 Age \u2502  Title   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice  \u2502 30  \u2502 Engineer \u2502\n\u2502 Bob    \u2502 25  \u2502 Designer \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next","text":"<ul> <li>Configure widths, wrapping, and truncation in the Usage guide</li> <li>Learn the format mini-language and table flags in the Formatting   guide</li> <li>Explore built-in Styles</li> <li>Jump to the API reference</li> </ul>"},{"location":"recipes/","title":"Recipes","text":"<p>Practical, copy-paste examples demonstrating common Craftable patterns and advanced techniques.</p>"},{"location":"recipes/#color-code","title":"Color-code negative values with ANSI escape codes","text":"<p>Use a postprocessor to add red coloring to negative numbers:</p> <pre><code>from craftable import get_table\n\ndef red_negative(original, text, row, col_idx):\n    try:\n        if float(original) &lt; 0:\n            return f\"\\x1b[31m{text}\\x1b[0m\"  # red\n    except (ValueError, TypeError):\n        pass\n    return text\n\ndata = [\n    [\"Widget A\", 1250.50, -45.20],\n    [\"Widget B\", -320.00, 150.75],\n    [\"Widget C\", 890.25, 220.00],\n]\n\nprint(get_table(\n    data,\n    header_row=[\"Product\", \"Revenue\", \"Cost\"],\n    col_defs=[\"&lt;20\", \"&gt;10.2f\", \"&gt;10.2f\"],\n    postprocessors=[None, red_negative, red_negative],\n))\n</code></pre> <p>Example output (colors removed for clarity):</p> <pre><code>       Product        \u2502  Revenue   \u2502    Cost    \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Widget A             \u2502    1250.50 \u2502     -45.20 \n Widget B             \u2502    -320.00 \u2502     150.75 \n Widget C             \u2502     890.25 \u2502     220.00 \n</code></pre>"},{"location":"recipes/#currency","title":"Format currency with prefix and conditional coloring","text":"<p>Combine prefix formatting with postprocessors for currency display:</p> <pre><code>from craftable import get_table\n\ndef color_by_value(original, text, row, col_idx):\n    try:\n        val = float(original)\n        if val &lt; 0:\n            return f\"\\x1b[31m{text}\\x1b[0m\"  # red\n        elif val &gt; 1000:\n            return f\"\\x1b[32m{text}\\x1b[0m\"  # green\n    except (ValueError, TypeError):\n        pass\n    return text\n\ntransactions = [\n    [\"Groceries\", -152.43],\n    [\"Paycheck\", 2500.00],\n    [\"Utilities\", -89.12],\n    [\"Bonus\", 1500.00],\n]\n\nprint(get_table(\n    transactions,\n    header_row=[\"Description\", \"Amount\"],\n    col_defs=[\"\", \"&lt;$ (&gt;10.2f)\"],\n    postprocessors=[None, color_by_value],\n))\n</code></pre> <p>Example output (colors removed for clarity):</p> <pre><code> Description \u2502   Amount\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Groceries   \u2502 $  -152.43\n Paycheck    \u2502 $  2500.00\n Utilities   \u2502 $   -89.12\n Bonus       \u2502 $  1500.00\n</code></pre>"},{"location":"recipes/#accounting-ledger","title":"Render an accounting ledger","text":"<p>Use a post-processor to transform standard currency into the specialized accounting format.</p> <pre><code>from datetime import date\nimport re\nfrom craftable import get_table\n\n# Define the format definition as well as a regular expression pattern to select\n# only the number and sign. Replace symbols, separators, and decimal as needed.\naccounting_def = f\"&lt;$ (&gt;,.2f) \"\n#                             separator  v        v  decimal\npadded_num = re.compile(r'[- ]?(\\d{1,3}(\\,\\d{3})*\\.\\d{2}) ')\n\ndef accounting_format(original, text, row, col_idx):\n    if original &lt;= 0:\n        print(text)\n        match = re.search(padded_num, text)\n        print(match)\n        if match:\n            full_text = match.group(0)\n            num_part = match.group(1)\n            if original &lt; 0:\n                new_text = f\"({num_part})\"\n            else:\n                new_text = (\" \" * (len(full_text) - 2)) + \"- \"\n            return re.sub(padded_num, new_text, text)\n    return text\n\ndata = [\n    [ date(2025, 6, 15), \"Lowe's\", -54.25, 98.23 ],\n    [ date(2025, 6, 17), \"Walmart\", -62.83, 35.4 ],\n    [ date(2025, 6, 17), \"Petsmart\", -35.4, 0 ],\n    [ date(2025, 6, 18), \"Deposit\", 1500, 1500 ],\n]\n\nprint(get_table(\n    data,\n    header_row=[\"Date\", \"Description\", \"Amount\", \"Balance\"],\n    col_defs=[\"\", \"\", accounting_def, accounting_def],\n    postprocessors=[None, None, accounting_format, accounting_format],\n))\n</code></pre> <p>Example output:</p> <pre><code>    Date    \u2502 Description \u2502    Amount   \u2502   Balance\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 2025-06-15 \u2502 Lowe's      \u2502 $   (54.25) \u2502 $    98.23\n 2025-06-17 \u2502 Walmart     \u2502 $   (62.83) \u2502 $    35.40\n 2025-06-17 \u2502 Petsmart    \u2502 $   (35.40) \u2502 $        -\n 2025-06-18 \u2502 Deposit     \u2502 $ 1,500.00  \u2502 $ 1,500.00\n</code></pre>"},{"location":"recipes/#icons","title":"Build a progress/status indicator table","text":"<p>Use Unicode characters and postprocessors for visual status:</p> <pre><code>from craftable import get_table\n\ndef status_icon(original, text, row, col_idx):\n    status_map = {\n        \"done\": \"\u2713\",\n        \"pending\": \"\u29d7\",\n        \"failed\": \"\u2717\",\n    }\n    return status_map.get(original, text)\n\ntasks = [\n    [\"Deploy to prod\", \"done\"],\n    [\"Run tests\", \"done\"],\n    [\"Update docs\", \"pending\"],\n    [\"Code review\", \"failed\"],\n]\n\nprint(get_table(\n    tasks,\n    header_row=[\"Task\", \"Status\"],\n    col_defs=[\"\", \"^8\"],\n    postprocessors=[None, status_icon],\n))\n</code></pre> <p>Example output:</p> <pre><code>      Task      \u2502  Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Deploy to prod \u2502 \u2713\n Run tests      \u2502 \u2713\n Update docs    \u2502 \u29d7\n Code review    \u2502 \u2717\n</code></pre>"},{"location":"recipes/#dates","title":"Convert dates with preprocessor, color with postprocessor","text":"<p>Chain preprocessing (for formatting) and postprocessing (for decoration):</p> <pre><code>from craftable import get_table\nfrom datetime import date, timedelta\n\ndef format_date(val, row, col_idx):\n    if isinstance(val, date):\n        return val.strftime(\"%Y-%m-%d\")\n    return val\n\ndef highlight_recent(original, text, row, col_idx):\n    if isinstance(original, date):\n        days_ago = (date.today() - original).days\n        if days_ago &lt; 7:\n            return f\"\\x1b[1m{text}\\x1b[0m\"  # bold\n    return text\n\nevents = [\n    [\"Meeting\", date.today() - timedelta(days=2)],\n    [\"Launch\", date.today() - timedelta(days=30)],\n    [\"Review\", date.today()],\n]\n\nprint(get_table(\n    events,\n    header_row=[\"Event\", \"Date\"],\n    col_defs=[\"&lt;20\", \"&lt;12\"],\n    preprocessors=[None, format_date],\n    postprocessors=[None, highlight_recent],\n))\n</code></pre> <p>Example output (bold removed for clarity):</p> <pre><code>        Event         \u2502     Date     \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Meeting              \u2502 2025-11-13   \n Launch               \u2502 2025-10-16   \n Review               \u2502 2025-11-15   \n</code></pre>"},{"location":"recipes/#dateparser","title":"Parse fuzzy date strings with dateparser","text":"<p>Use the dateparser library to parse various date string formats and format them consistently with a preprocessor:</p> <pre><code>from craftable import get_table\n\n# Various date formats that dateparser can handle\nappointments = [\n    [\"Team standup\", \"tomorrow at 9am\"],\n    [\"Client demo\", \"next Friday\"],\n    [\"Code review\", \"in 3 days\"],\n    [\"Release\", \"2025-12-01\"],\n    [\"Conference\", \"Jan 15, 2026\"],\n]\n\ndef parse_date_string(val, row, col_idx):\n    \"\"\"Parse string dates with dateparser and format as YYYY-MM-DD.\"\"\"\n    if not isinstance(val, str):\n        return val\n\n    try:\n        import dateparser\n        parsed = dateparser.parse(val)\n        if parsed:\n            return parsed.strftime(\"%Y-%m-%d\")\n    except ImportError:\n        # dateparser not available, return original\n        pass\n    except Exception:\n        # Parsing failed, return original\n        pass\n\n    return val\n\nprint(get_table(\n    appointments,\n    header_row=[\"Event\", \"Date\"],\n    col_defs=[\"&lt;20\", \"&lt;12\"],\n    preprocessors=[None, parse_date_string],\n))\n</code></pre> <p>Example output (dates relative to execution time):</p> <pre><code>       Event         \u2502     Date     \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Team standup        \u2502 2025-11-17   \n Client demo         \u2502 2025-11-21   \n Code review         \u2502 2025-11-19   \n Release             \u2502 2025-12-01   \n Conference          \u2502 2026-01-15   \n</code></pre> <p>Note: Requires the <code>dateparser</code> package: <code>pip install dateparser</code></p>"},{"location":"recipes/#hierarchy","title":"Generate a multi-level grouped summary","text":"<p>Build hierarchical data with visual indentation:</p> <pre><code>from craftable import get_table\n\ndef indent_category(value, row, col_idx):\n    if isinstance(value, str) and value.startswith(\"  \"):\n        return f\"  \u2514\u2500 {value.strip()}\"\n    return value\n\ndata = [\n    [\"Electronics\", None, 5420.00],\n    [\"  Laptops\", 3, 3200.00],\n    [\"  Monitors\", 5, 2220.00],\n    [\"Furniture\", None, 1890.50],\n    [\"  Desks\", 2, 890.00],\n    [\"  Chairs\", 4, 1000.50],\n]\n\nprint(get_table(\n    data,\n    header_row=[\"Category\", \"Qty\", \"Total\"],\n    col_defs=[\"&lt;25\", \"&gt;5\", \"&gt;10.2f\"],\n    preprocessors=[indent_category, None, None],\n))\n</code></pre> <p>Example output:</p> <pre><code>          Category         \u2502  Qty  \u2502   Total\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Electronics               \u2502       \u2502    5420.00\n   \u2514\u2500 Laptops              \u2502     3 \u2502    3200.00\n   \u2514\u2500 Monitors             \u2502     5 \u2502    2220.00\n Furniture                 \u2502       \u2502    1890.50\n   \u2514\u2500 Desks                \u2502     2 \u2502     890.00\n   \u2514\u2500 Chairs               \u2502     4 \u2502    1000.50\n</code></pre>"},{"location":"recipes/#markdown-table","title":"Build a linked styles overview table (Markdown)","text":"<p>Generate a Markdown table with postprocessor-added links to page anchors:</p> <pre><code>from itertools import zip_longest\nfrom craftable import get_table\nfrom craftable.styles import MarkdownStyle\n\ndisplay = [\n    \"NoBorderScreenStyle\",\n    \"BasicScreenStyle\",\n    \"RoundedBorderScreenStyle\",\n    \"MarkdownStyle\",\n    \"ASCIIStyle\",\n]\nexport = [\n    \"XlsxStyle\",\n    \"OdsStyle\",\n    \"OdtStyle\",\n    \"DocxStyle\",\n    \"RtfStyle\",\n]\n\nrows = [list(pair) for pair in zip_longest(display, export)]\n\nanchor_map = {\n    \"NoBorderScreenStyle\": \"style-noborder\",\n    \"BasicScreenStyle\": \"style-basic\",\n    \"RoundedBorderScreenStyle\": \"style-rounded\",\n    \"MarkdownStyle\": \"style-markdown\",\n    \"ASCIIStyle\": \"style-ascii\",\n    \"XlsxStyle\": \"style-xlsx\",\n    \"OdsStyle\": \"style-ods\",\n    \"OdtStyle\": \"style-odt\",\n    \"DocxStyle\": \"style-docx\",\n    \"RtfStyle\": \"style-rtf\",\n}\n\ndef linkify(original, text, row, col_idx):\n    if not text.strip():\n        return text\n    anchor = anchor_map.get(original, \"\")\n    anchor_text = f\"[{original}](#{anchor})\" if anchor else original\n    return text.replace(original, anchor_text)\n\nprint(get_table(\n    rows,\n    header_row=[\"Display Styles\", \"Export Styles\"],\n    style=MarkdownStyle(),\n    postprocessors=[linkify,linkify],\n))\n</code></pre> <p>Example output (raw Markdown table):</p> <pre><code>|      Display Styles      | Export Styles |\n| ------------------------ | ------------- |\n| [NoBorderScreenStyle](#style-noborder)      | [XlsxStyle](#style-xlsx)     |\n| [BasicScreenStyle](#style-basic)         | [OdsStyle](#style-ods)      |\n| [RoundedBorderScreenStyle](#style-rounded) | [OdtStyle](#style-odt)      |\n| [MarkdownStyle](#style-markdown)            | [DocxStyle](#style-docx)     |\n| [ASCIIStyle](#style-ascii)               | [RtfStyle](#style-rtf)      |\n</code></pre> <p>See this table rendered on the styles page.</p>"},{"location":"recipes/#truncate","title":"Truncate long log messages for compact output","text":"<p>Use the truncate flag for log-friendly tables:</p> <pre><code>from craftable import get_table\nfrom craftable.styles import NoBorderScreenStyle\n\nlogs = [\n    [\"2025-01-15 10:23:45\", \"INFO\", \"Application started successfully\"],\n    [\"2025-01-15 10:24:12\", \"WARN\", \"Database connection pool is running low on available connections\"],\n    [\"2025-01-15 10:25:03\", \"ERROR\", \"Failed to process request: timeout exceeded after 30 seconds\"],\n]\n\nprint(get_table(\n    logs,\n    header_row=[\"Timestamp\", \"Level\", \"Message\"],\n    col_defs=[\"&lt;19\", \"&lt;6\", \"40T\"],  # T flag = truncate with ellipsis\n    style=NoBorderScreenStyle(),\n))\n</code></pre> <p>Example output:</p> <pre><code>      Timestamp      \u2502 Level  \u2502                 Message\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 2025-01-15 10:23:45 \u2502 INFO   \u2502 Application started successfully\n 2025-01-15 10:24:12 \u2502 WARN   \u2502 Database connection pool is running low\u2026\n 2025-01-15 10:25:03 \u2502 ERROR  \u2502 Failed to process request: timeout exce\u2026\n</code></pre>"},{"location":"recipes/#log","title":"Long log messages for without wrapping","text":"<p>Use an appropriate style and set <code>lazy_end=True</code>:</p> <pre><code>from craftable import get_table\nfrom craftable.styles import ASCIIStyle\n\nlogs = [\n    [\"2025-01-15 10:23:45\", \"INFO\", \"Application started successfully\"],\n    [\"2025-01-15 10:24:12\", \"WARN\", \"Database connection pool is running low on available connections\"],\n    [\"2025-01-15 10:25:03\", \"ERROR\", \"Failed to process request: timeout exceeded after 30 seconds\"],\n]\n\nprint(get_table(\n    logs,\n    header_row=[\"Timestamp\", \"Level\", \"Message\"],\n    style=ASCIIStyle(),\n    lazy_end=True,\n))\n</code></pre> <p>Example output:</p> <pre><code>+---------------------+-------+-------------------------------------------------------------------\n|      Timestamp      | Level |                             Message\n+---------------------+-------+-------------------------------------------------------------------\n| 2025-01-15 10:23:45 | INFO  | Application started successfully\n| 2025-01-15 10:24:12 | WARN  | Database connection pool is running low on available connections\n| 2025-01-15 10:25:03 | ERROR | Failed to process request: timeout exceeded after 30 seconds\n+---------------------+-------+-------------------------------------------------------------------\n</code></pre>"},{"location":"recipes/#pivot","title":"Pivot data from columnar to row format","text":"<p>Transform a mapping-of-lists into a transposed table:</p> <pre><code>from craftable import get_table\nfrom craftable.adapters import from_mapping_of_lists\n\nstats = {\n    \"metric\": [\"CPU %\", \"Memory MB\", \"Disk I/O\"],\n    \"server_a\": [45.2, 2048, 1250],\n    \"server_b\": [78.9, 4096, 3420],\n    \"server_c\": [23.1, 1024, 890],\n}\n\nrows, headers = from_mapping_of_lists(stats)\nprint(get_table(rows, header_row=headers, col_defs=[\"&lt;12\", \"&gt;10\", \"&gt;10\", \"&gt;10\"]))\n</code></pre> <p>Example output:</p> <pre><code>    metric    \u2502  server_a  \u2502  server_b  \u2502  server_c  \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n CPU %        \u2502       45.2 \u2502       78.9 \u2502       23.1 \n Memory MB    \u2502       2048 \u2502       4096 \u2502       1024 \n Disk I/O     \u2502       1250 \u2502       3420 \u2502        890 \n</code></pre>"},{"location":"recipes/#trend","title":"Create a comparison table with trend indicators","text":"<p>Show before/after comparisons with visual markers:</p> <pre><code>from craftable import get_table\n\ndef trend_arrow(val, row, col_idx):\n    \"\"\"Add up/down arrows based on change from prior column.\"\"\"\n    trend = \" \"\n    try:\n        prior_val = row[col_idx - 1]\n        if val &gt; prior_val:\n            trend = \"\u2191\"\n        elif val &lt; prior_val:\n            trend = \"\u2193\"\n    except Exception:\n        pass\n\n    return f\"{val} {trend}\"\n\n\n# Manually add trend info to data\ncomparisons = [\n    [\"Response time (ms)\", \"245\", \"198\"],\n    [\"Error rate (%)\", \"2.1\", \"0.8\"],\n    [\"Throughput (req/s)\", \"1200\", \"1450\"],\n]\n\nprint(\n    get_table(\n        comparisons,\n        header_row=[\"Metric\", \"Before\", \"After\"],\n        col_defs=[\"&lt;20\", \"&gt;10\", \"&gt;10\"],\n        preprocessors=[None, None, trend_arrow],\n    )\n)\n</code></pre> <p>Example output:</p> <pre><code>        Metric        \u2502   Before   \u2502   After    \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Response time (ms)   \u2502        245 \u2502      198 \u2193 \n Error rate (%)       \u2502        2.1 \u2502      0.8 \u2193 \n Throughput (req/s)   \u2502       1200 \u2502     1450 \u2191 \n</code></pre>"},{"location":"recipes/#progress-bars","title":"Display percentages with progress bars","text":"<p>Use Unicode block characters for inline progress visualization:</p> <pre><code>from craftable import get_table\n\ndef progress_bar(val, row, col_idx):\n    try:\n        pct = float(val)\n        bars = int(pct / 10)\n        return \"\u2588\" * bars + \"\u2591\" * (10 - bars) + f\" {val}%\"\n    except (ValueError, TypeError):\n        return val\n\ncompletion = [\n    [\"Backend API\", 85],\n    [\"Frontend UI\", 60],\n    [\"Database migrations\", 100],\n    [\"Documentation\", 45],\n]\n\nprint(get_table(\n    completion,\n    header_row=[\"Component\", \"Progress\"],\n    preprocessors=[None, progress_bar],\n))\n</code></pre> <p>Example output:</p> <pre><code>      Component      \u2502     Progress\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Backend API         \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591 85%\n Frontend UI         \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591 60%\n Database migrations \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 100%\n Documentation       \u2502 \u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591 45%\n</code></pre>"},{"location":"recipes/#csv-select","title":"Read a CSV and select columns","text":"<p>Load a CSV with Python's standard library and build a table using only a subset of columns. This example also formats salary with a left-aligned \"$\" prefix and formats a percentage column using the normal f-string <code>%</code> format type.</p> <pre><code>import csv\nfrom craftable import get_table\nfrom craftable.adapters import from_dicts\n\n# employees.csv (example with interleaved extra columns):\n# id,name,dept,manager,salary,currency,bonus_pct,notes,location\n# 101,Alice,Engineering,Elaine,120000,USD,0.10,Senior engineer,NYC\n# 102,Bob,Sales,Marco,85000,USD,0.05,Top performer,Austin\n# 103,Carol,Support,Janet,65000,USD,0.07,,Remote\n\ndef to_float(val, *_):  # note the *_ to accept unused extra args\n    try:\n        return float(val)\n    except (TypeError, ValueError):\n        return val\n\nwith open(\"employees.csv\", newline=\"\", encoding=\"utf-8\") as f:\n    reader = csv.DictReader(f)\n\n    # Keep only the columns we care about, in the order we want\n    desired = [\"name\", \"dept\", \"salary\", \"bonus_pct\"]\n    rows, headers = from_dicts(reader, columns=desired)\n\n# Optionally, prettify headers\nheaders = [h.replace(\"_\", \" \").title() for h in headers]\n\nprint(get_table(\n    rows,\n    header_row=headers,\n    col_defs=[\n        \"\",               # name\n        \"\",               # dept\n        \"&lt;$ (&gt;,.0f)\",     # salary: left-aligned $ with right-aligned, grouped value\n        \"(&gt;.1%)\",         # bonus_pct: normal f-string percentage formatting\n    ],\n    preprocessors=[None, None, to_float, to_float],\n))\n</code></pre> <p>Example output:</p> <pre><code> Name                 \u2502 Dept        \u2502 Salary        \u2502 bonus_pct\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Alice                \u2502 Engineering \u2502 $       120,000\u2502    10.0%\n Bob                  \u2502 Sales       \u2502 $        85,000\u2502     5.0%\n Carol                \u2502 Support     \u2502 $        65,000\u2502     7.0%\n</code></pre>"},{"location":"recipes/#pandas-variant","title":"Pandas variant","text":"<p>Do the same selection and formatting using pandas. Pandas automatically coerces numbers when reading files, eliminating the need for the preprocessor callback.</p> <pre><code># Requires pandas (optional dependency)\nimport pandas as pd\nfrom craftable import get_table\nfrom craftable.adapters import from_dataframe\n\n# Same CSV as above (with interleaved extra columns)\ndf = pd.read_csv(\"employees.csv\")\n\ndesired = [\"name\", \"dept\", \"salary\", \"bonus_pct\"]\nrows, headers = from_dataframe(df, columns=desired)\n\n# Optionally, prettify headers\nheaders = [h.replace(\"_\", \" \").title() for h in headers]\n\nprint(get_table(\n    rows,\n    header_row=headers,\n    col_defs=[\n        \"\",               # name\n        \"\",               # dept\n        \"&lt;$ (&gt;,.0f)\",     # salary: left-aligned $ with right-aligned, grouped value\n        \"(&gt;.1%)\",         # bonus_pct: normal f-string percentage formatting\n    ],\n))\n</code></pre>"},{"location":"styles/","title":"Styles","text":"<p>Craftable provides two families of styles:</p> <ul> <li>Display/printable styles that render strings for terminals, logs, and docs   (used with <code>get_table()</code>).</li> <li>Export/document styles that generate files (used with <code>export_table()</code>).</li> </ul> <p>Use display styles when you want immediate, human-readable output (terminal/Markdown/ASCII). Use export styles when you want an artifact like .xlsx or .docx.</p> Display Styles Export Styles NoBorderScreenStyle XlsxStyle BasicScreenStyle OdsStyle RoundedBorderScreenStyle OdtStyle MarkdownStyle DocxStyle ASCIIStyle RtfStyle <p>Note</p> <p>The table above was generated using craftable's get_table function. You can view the code in the recipes.</p>"},{"location":"styles/#available-styles","title":"Available styles","text":""},{"location":"styles/#style-noborder","title":"NoBorderScreenStyle (default)","text":"<p>Minimal, whitespace-delimited with a simple header separator.</p> <pre><code>from craftable import get_table\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"]))\n</code></pre> <p>Output:</p> <pre><code>  Name \u2502 Age \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\n Alice \u2502 30  \n Bob   \u2502 25  \n</code></pre>"},{"location":"styles/#style-basic","title":"BasicScreenStyle","text":"<p>Classic box drawing with Unicode characters (\u2502 \u2500 \u250c \u2510 \u2514 \u2518 \u251c \u2524 \u252c \u2534 \u253c).</p> <pre><code>from craftable import get_table\nfrom craftable.styles import BasicScreenStyle\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=BasicScreenStyle()))\n</code></pre> <p>Output:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Name \u2502 Age \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice \u2502 30  \u2502\n\u2502 Bob   \u2502 25  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"styles/#style-rounded","title":"RoundedBorderScreenStyle","text":"<p>Rounded corners for a softer look (\u256d \u256e \u2570 \u256f \u2502 \u2500).</p> <pre><code>from craftable import get_table\nfrom craftable.styles import RoundedBorderScreenStyle\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=RoundedBorderScreenStyle()))\n</code></pre> <p>Output:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502  Name \u2502 Age \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice \u2502 30  \u2502\n\u2502 Bob   \u2502 25  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"styles/#style-markdown","title":"MarkdownStyle","text":"<p>GitHub-flavored Markdown tables for documentation.</p> <pre><code>from craftable import get_table\nfrom craftable.styles import MarkdownStyle\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=MarkdownStyle()))\n</code></pre> <p>Output:</p> <pre><code>|  Name | Age |\n| ----- | --- |\n| Alice | 30  |\n| Bob   | 25  |\n</code></pre>"},{"location":"styles/#style-ascii","title":"ASCIIStyle","text":"<p>Plain ASCII borders for terminals and logs.</p> <pre><code>from craftable import get_table\nfrom craftable.styles import ASCIIStyle\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=ASCIIStyle()))\n</code></pre> <p>Output:</p> <pre><code>+-------+-----+\n|  Name | Age |\n+-------+-----+\n| Alice | 30  |\n| Bob   | 25  |\n+-------+-----+\n</code></pre>"},{"location":"styles/#options-that-affect-layout","title":"Options that affect layout","text":"<p>From <code>get_table</code>:</p> <ul> <li><code>table_width</code>: set the maximum width for the entire table</li> <li><code>lazy_end</code>: omit the right border for more compact output</li> <li><code>separate_rows</code>: add a horizontal separator between rows (non-Markdown styles)</li> </ul> <p>From style classes (subclasses of <code>TableStyle</code>):</p> <ul> <li><code>cell_padding</code>: style-dependent spacing inside each cell</li> <li><code>min_width</code>: style-dependent minimum column width</li> <li><code>terminal_style</code>: determines whether the maximum width of a table is   potentially constrained by the width of the terminal window.</li> </ul>"},{"location":"styles/#customizing-styles","title":"Customizing styles","text":"<p>You can fine-tune the look of your tables either by tweaking an instance of a built\u2011in style or by creating your own style class that derives from <code>TableStyle</code>.</p>"},{"location":"styles/#option-1-modify-a-builtin-style-instance","title":"Option 1: Modify a built\u2011in style instance","text":"<p>All visual details are exposed as attributes on the style object. You can instantiate a style, change a few attributes, and pass it to <code>get_table</code>.</p> <pre><code>from craftable import get_table\nfrom craftable.styles import BasicScreenStyle, BoxChars\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\n\nstyle = BasicScreenStyle()\n\n# Make cells roomier and swap in double-line rules for the header separator\nstyle.cell_padding = 2\nstyle.header_bottom_line = BoxChars.DOUBLE_HORIZONTAL\nstyle.header_bottom_delimiter = BoxChars.DOUBLE_VERTICAL_AND_HORIZONTAL\nstyle.header_bottom_left = BoxChars.DOUBLE_VERTICAL_AND_RIGHT\nstyle.header_bottom_right = BoxChars.DOUBLE_VERTICAL_AND_LEFT\n\n# Use double verticals between values\nstyle.values_delimiter = BoxChars.DOUBLE_VERTICAL\nstyle.values_left = BoxChars.DOUBLE_VERTICAL\nstyle.values_right = BoxChars.DOUBLE_VERTICAL\n\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=style))\n</code></pre> <p>Tip</p> <p>Start from the style closest to what you want (e.g., <code>BasicScreenStyle</code>, <code>RoundedBorderScreenStyle</code>, or <code>MarkdownStyle</code>) and override only a handful of attributes.</p> <p>All border characters come from <code>BoxChars</code> (a small enum of Unicode box\u2011drawing symbols). You can also use plain strings like <code>\"|\"</code> or <code>\"-\"</code> if you prefer pure ASCII.</p>"},{"location":"styles/#option-2-create-your-own-style-class","title":"Option 2: Create your own style class","text":"<p>For full control, subclass <code>TableStyle</code> and set the attributes you care about in <code>__init__</code>. Here\u2019s a minimal ASCII style that uses <code>+</code>, <code>-</code>, and <code>|</code>.</p> <pre><code>from craftable import get_table\nfrom craftable.styles import TableStyle, BoxChars\n\nclass DoubleBorderStyle(TableStyle):\n    \"\"\"Bold outer borders with double-line rules and single-line interior.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Only override what makes this style unique\n        # Use double lines for outer borders (horizontal and vertical)\n        self.header_top_line = BoxChars.DOUBLE_HORIZONTAL\n        self.values_bottom_line = BoxChars.DOUBLE_HORIZONTAL\n        self.header_left = BoxChars.DOUBLE_VERTICAL\n        self.header_right = BoxChars.DOUBLE_VERTICAL\n        self.values_left = BoxChars.DOUBLE_VERTICAL\n        self.values_right = BoxChars.DOUBLE_VERTICAL\n\n        # Corners: pure double lines\n        self.header_top_left = BoxChars.DOUBLE_DOWN_AND_RIGHT\n        self.header_top_right = BoxChars.DOUBLE_DOWN_AND_LEFT\n        self.values_bottom_left = BoxChars.DOUBLE_UP_AND_RIGHT\n        self.values_bottom_right = BoxChars.DOUBLE_UP_AND_LEFT\n\n        # Intersections where double borders meet single interior lines\n        self.header_top_delimiter = BoxChars.DOUBLE_HORIZONTAL_AND_SINGLE_DOWN\n        self.header_bottom_left = BoxChars.SINGLE_VERTICAL_AND_DOUBLE_RIGHT\n        self.header_bottom_right = BoxChars.SINGLE_VERTICAL_AND_DOUBLE_LEFT\n        self.values_bottom_delimiter = BoxChars.DOUBLE_HORIZONTAL_AND_SINGLE_UP\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=DoubleBorderStyle()))\n</code></pre> <p>Output:</p> <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551  Name \u2502 Age \u2551\n\u255f\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2562\n\u2551 Alice \u2502 30  \u2551\n\u2551 Bob   \u2502 25  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>Notes</p> <ul> <li>You only need to override the attributes that make your style unique. In this   example, we changed just the outer borders (8 attributes) and inherited ~20+   other values from <code>TableStyle</code>.</li> <li>If you want to build on an existing style instead of <code>TableStyle</code>, subclass it   directly (e.g., <code>class MyStyle(BasicScreenStyle)</code>).</li> <li>Markdown layout is handled by <code>MarkdownStyle</code> with <code>align_char=\":\"</code> and   <code>terminal_style=False</code>. If you need a Markdown variant, subclass   <code>MarkdownStyle</code> instead and tweak only what you need.</li> </ul>"},{"location":"styles/#recipe-compactdense-tables","title":"Recipe: Compact/Dense tables","text":"<p>If you want maximum information density, reduce padding on a base style:</p> <pre><code>from craftable import get_table\nfrom craftable.styles import BasicScreenStyle\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\n\ndense = BasicScreenStyle()\ndense.cell_padding = 0\ndense.min_width = 1\nprint(get_table(rows, header_row=[\"Name\", \"Age\"], style=dense))\n</code></pre>"},{"location":"styles/#style-code-references","title":"Style Code References","text":"<p>For class-level APIs like <code>TableStyle</code> and <code>BoxChars</code>, see the Text Style API and Document Style API.</p>"},{"location":"styles/#document-export-styles","title":"Document / Export Styles","text":"<p>Craftable also includes styles for writing files instead of rendering terminal text. Use these with <code>export_table()</code>.</p>"},{"location":"styles/#style-xlsx","title":"XlsxStyle","text":"<p>Excel workbook output (<code>.xlsx</code>, binary). Best for spreadsheets and BI tools.</p>"},{"location":"styles/#style-ods","title":"OdsStyle","text":"<p>OpenDocument Spreadsheet (<code>.ods</code>, binary), compatible with LibreOffice and others.</p>"},{"location":"styles/#style-odt","title":"OdtStyle","text":"<p>OpenDocument Text (<code>.odt</code>, binary) for word processors like LibreOffice Writer.</p>"},{"location":"styles/#style-docx","title":"DocxStyle","text":"<p>Microsoft Word document (<code>.docx</code>, binary). Good for formal reports.</p>"},{"location":"styles/#style-rtf","title":"RtfStyle","text":"<p>Rich Text Format (<code>.rtf</code>, text). Portable with broad editor support.</p> <p>Example:</p> <pre><code>from craftable import export_table\nfrom craftable.adapters import from_dicts\nfrom craftable.styles import XlsxStyle\n\nrows, headers = from_dicts([\n  {\"name\": \"Alice\", \"age\": 30},\n  {\"name\": \"Bob\", \"age\": None},\n])\n\nexport_table(\n  rows,\n  header_row=headers,\n  style=XlsxStyle(),\n  file=\"people.xlsx\",\n  none_text=\"\u2014\",\n)\n</code></pre> <p>Notes: - Some document styles provide a dedicated writer; <code>export_table()</code> will use it when a <code>file</code> is supplied. - If a style renders to bytes, <code>export_table()</code> writes in binary mode for path-like <code>file</code> values. - Non-terminal styles typically set <code>terminal_style=False</code> (terminal width detection is skipped).</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide shows the basics of how to invoke and use craftable.</p>"},{"location":"usage/#core-functions","title":"Core Functions","text":"<p>There are two main functions used to generate tables:</p> <ul> <li><code>get_table</code> \u2014 render a complete table (headers, rows, borders)</li> <li><code>export_table</code> \u2014 save a table to a file</li> </ul> <p>Note</p> <p>See the API reference for full function signatures and details.</p> <p><code>get_table</code> is the primary entry point. In most cases, there will be no need to call any other functions. 'get_table' has the following definition:</p> <pre><code>def get_table(\n  value_rows: Iterable[Iterable[Any]],\n  header_row: Iterable[Any] | None = None,\n  style: TableStyle = NoBorderScreenStyle(),\n  col_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n  header_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n  table_width: int = 0,\n  lazy_end: bool = False,\n  separate_rows: bool = False,\n  preprocessors: PreprocessorCallbackList | None = None,\n  postprocessors: PostprocessorCallbackList | None = None,\n  none_text: str = \"\",\n) -&gt; str:\n</code></pre>"},{"location":"usage/#values","title":"Values","text":"<p><code>value_rows</code> is the only required argument. It is a two-dimensional collection of data to be displayed. It should a collection of rows, with each row being a collection of cell values. The structure should resemble this:</p> <pre><code>[\n  [&lt;val&gt;, &lt;val&gt;],   # row\n  [&lt;val&gt;, &lt;val&gt;],   # row\n]\n</code></pre> <p>The table will be tolerant of jagged data, appending empty cells as needed to ensure a clean tabular output.</p>"},{"location":"usage/#headers","title":"Headers","text":"<p>The optional <code>header_row</code> named argument should contain a single collection of values to be used as headers for the table. If no header_row is specified, then no header will be displayed.</p> <p>The following demonstrates usage of this parameter:</p> <pre><code>from craftable import get_table\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\nprint(get_table(rows, header_row=[\"Name\", \"Age\"]))\n</code></pre> <p>Output:</p> <pre><code>  Name \u2502 Age \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\n Alice \u2502 30  \n Bob   \u2502 25  \n</code></pre> <p>Note</p> <p>If a particular table style requires that a header exist (e.g., Markdown tables), then an empty header row will be generated if none is specified.</p>"},{"location":"usage/#column-and-header-definitions","title":"Column and Header Definitions","text":"<p><code>col_defs</code> and <code>header_defs</code> are collections of strings that define how each column should be formatted. These strings use Python's format mini-language plus table-specific flags (see Formatting guide). The simplicity and elegance of this is where craftable shines and the main reason for its creation.</p> <pre><code>from craftable import get_table\n\nrows = [[\"Alice\", 30], [\"Bob\", 25]]\ncol_defs = [\"10\", \"&gt;5\"]  # left-align 10 chars, right-align 5 chars\nprint(get_table(rows, col_defs=col_defs))\n</code></pre> <p>Note</p> <p>Column definitions are internally converted to <code>ColDef</code> objects for processing, but you should always use string specifications as shown above. See the API reference for implementation details.</p> <p>Default <code>col_defs</code> create auto-sized, left-aligned cells. Default <code>header_defs</code> create auto-sized, center-aligned cells.</p>"},{"location":"usage/#style-and-table-width","title":"Style and Table Width","text":"<ul> <li><code>style</code> specifies the style class to use to render the table. See below for   the list of included options.</li> <li><code>table_width</code> constrains the entire rendered table width if desired. Note that   this is the actual total width of the string, including all borders and   padding.</li> <li><code>lazy_end=True</code> omits the rightmost border. This is mostly useful for styles   that are geared for file (vs. screen/terminal) output (ASCII and Markdown). If   the data is structured such the width of the value in the last column varies   significantly (but can be quite large), this can eliminate a lot of wasted   disk space by right-trimming the end of each line.</li> <li><code>separate_rows=True</code> draws a divider line between each data row.</li> <li><code>none_text=\"\"</code> specifies the text to display for None values. By default, None   values are displayed as empty strings.</li> <li><code>preprocessors</code> / <code>postprocessors</code> (advanced): column-indexed callbacks.   Preprocessors run before formatting and influence widths; postprocessors run   after sizing/alignment/wrapping for decorations like colors/styles (should   not change displayed width).</li> </ul> <p>The following is a more complete, styled example:</p> <pre><code>from craftable import get_table\nfrom craftable.styles import RoundedBorderScreenStyle\n\nrows = [[\"Alice\", 30], [\"Bob\", 25], [\"Charlie\", 35]]\nprint(get_table(\n    rows,\n    header_row=[\"Name\", \"Age\"],\n    col_defs=[\"A\",\"5&gt;\"],\n    header_defs=[\"&lt;\",\"&gt;\"],\n    style=RoundedBorderScreenStyle(),\n    table_width=30,\n    separate_rows=True,\n))\n</code></pre> <p>Output:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Name                 \u2502 Age \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Alice                \u2502  30 \u2502\n\u2502\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u2502\u25e6\u25e6\u25e6\u25e6\u25e6\u2502\n\u2502 Bob                  \u2502  25 \u2502\n\u2502\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u25e6\u2502\u25e6\u25e6\u25e6\u25e6\u25e6\u2502\n\u2502 Charlie              \u2502  35 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The style classes included with craftable are:</p> <ul> <li><code>NoBorderScreenStyle</code> \u2014 minimal, compact (default)</li> <li><code>BasicScreenStyle</code> \u2014 classic box drawing</li> <li><code>RoundedBorderScreenStyle</code> \u2014 rounded corners</li> <li><code>ASCIIStyle</code> \u2014 classic, 7-bit ASCII drawing</li> <li><code>MarkdownStyle</code> \u2014 GitHub-flavored Markdown tables</li> </ul> <p>Modifying existing styles or creating custom styles is trivial.</p> <p>See Styles for additional visual examples and the API reference for class details.</p>"},{"location":"usage/#quick-exporting-to-files","title":"Quick Exporting to Files","text":"<p>Use <code>export_table()</code> with a document style to write files directly:</p> <pre><code>from craftable import export_table\nfrom craftable.adapters import from_dicts\nfrom craftable.styles import XlsxStyle\n\ndata = [\n    {\"product\": \"Widget A\", \"price\": 19.99, \"stock\": 150},\n    {\"product\": \"Widget B\", \"price\": 29.99, \"stock\": 75},\n]\n\nrows, headers = from_dicts(data)\nexport_table(\n    rows,\n    header_row=headers,\n    style=XlsxStyle(),\n    file=\"report.xlsx\",\n    none_text=\"\u2014\",\n)\n</code></pre> <p>See more export styles in Styles.</p>"},{"location":"usage/#handling-none-values","title":"Handling None Values","text":"<p>Craftable replaces column values of <code>None</code> with configurable text before applying formatting and prefix/suffix:</p> <ul> <li>Global per-table: pass <code>none_text=\"\u2014\"</code> to <code>get_table()</code> or <code>export_table()</code>.</li> <li>Per column: set <code>ColDef.none_text</code> for selective overrides.</li> </ul> <p>Example:</p> <pre><code>from craftable import get_table, ColDefList\n\nrows = [[None, 12.34], [\"Bob\", None]]\nspecs = [\"^10\", \"&gt;8.2f\"]\ncol_defs = ColDefList.parse(specs)\ncol_defs[0].none_text = \"(n/a)\"  # only for first column\n\nprint(get_table(rows, header_row=[\"Name\", \"Value\"], col_defs=col_defs, none_text=\"\u2014\"))\n</code></pre> <p>Notes</p> <ul> <li>Prefixes and Suffixes in the format string are not applied to None values.</li> <li>Preprocessors and Postprocessors are called for None values.</li> <li>Per-column <code>none_text</code> takes precedence over the global parameter.</li> <li>The substituted text participates in width, truncation (T flag), and wrapping   like any other string.</li> </ul>"},{"location":"usage/#preprocessors-and-postprocessors","title":"Preprocessors and Postprocessors","text":"<p>Pre/Post processors provide per\u2011column hooks for transforming raw values and decorating already formatted text, with full row context.</p> <p>Preprocessors run beforfe any sizing or formatting is performed. This can be useful to conditionally hide certain values or to convert values that are not specifically supported by format specification mini-language, such as date/time formatting.</p> <p>Postprocessors run after all other formatting, alignment, and wrapping has occurred. This is likely most useful to conditionally add ANSI codes or Rich formatting codes that would otherwise affect the column size calculations.</p> <p>Signatures:</p> <pre><code># value before formatting\ndef preprocessor(value, row, col_idx) -&gt; Any: ...\n\n# original raw value &amp; formatted text after width/alignment/wrapping\ndef postprocessor(original_value, text, row, col_idx) -&gt; str: ...\n</code></pre> <p>Parameters:</p> Name When Description <code>value</code> / <code>original_value</code> Input Raw cell value prior to any formatting or prefix/suffix handling <code>text</code> Post only The fully formatted, aligned (and possibly wrapped) cell text <code>row</code> Both The entire list of original values for the current row <code>col_idx</code> Both Zero\u2011based column index for the cell <p>Behavior:</p> <ul> <li>Preprocessors run before width calculation, so their returned value affects sizing.</li> <li>Postprocessors run after formatting/alignment; their return text must keep the   same visible width (avoid adding/removing padding characters).</li> <li>Exceptions are swallowed (unless the column is strict) and the original   value/text is used.</li> <li>Use <code>None</code> in the callback list for columns without a processor.</li> </ul> <p>Example with both:</p> <pre><code>from craftable import get_table\nfrom datetime import date\n\ndef fmt_date(value, row, col_idx):\n  if hasattr(value, \"strftime\"):\n    return value.strftime(\"%Y-%m-%d\")\n  return value\n\ndef color_negative(original, text, row, col_idx):\n  try:\n    if float(original) &lt; 0:\n      return f\"\\x1b[31m{text}\\x1b[0m\"  # red\n  except Exception:\n    pass\n  return text\n\nrows = [[\"Sale\", -45.2, date(2025,11,15)], [\"Refund\", 12.5, date(2025,11,14)]]\nprint(get_table(\n  rows,\n  header_row=[\"Type\", \"Amount\", \"Date\"],\n  col_defs=[\"&lt;10\", \"&gt;10.2f\", \"&lt;12\"],\n  preprocessors=[None, None, fmt_date],\n  postprocessors=[None, color_negative, None],\n))\n</code></pre> <p>See the Formatting Guide for deeper discussion and patterns.</p>"},{"location":"usage/#working-with-adapters","title":"Working with Adapters","text":"<p>The <code>get_table</code> function works natively with a two-dimensional collection of data (i.e., list of lists) and an option list of header values. Hoowever, it also ships with a robust set of adapters to transform other data structures into craftable-compatible structures.</p> <p>Included adapters include:</p> <ul> <li>Dictionaries (JSON-like): <code>from_dicts</code></li> <li>Columnar (mapping of lists): <code>from_mapping_of_lists</code></li> <li>Dataclasses: <code>from_dataclasses</code></li> <li>Mixed models (Pydantic/attrs/plain): <code>from_models</code></li> <li>Database cursor/rows: <code>from_sql</code></li> <li>NumPy arrays: <code>from_numpy</code></li> <li>DataFrames (Pandas/Polars): <code>from_dataframe</code></li> <li>Raw tuples/lists: <code>from_records</code></li> </ul> <p>See details and patterns in Adapters.</p>"},{"location":"usage/#large-dataset-tips","title":"Large Dataset Tips","text":"<p>When working with large datasets, consider these optimization strategies:</p> <ul> <li>Text vs. Screen Styles: unless specified, the max width of a screen style   will be the terminal width (or 120 if run with no active terminal). This may   be limiting for very wide data sets. If the output is intended to be a text   file. Consider using ASCII ro Markdown styles, or modify a style to set the   <code>terminal_style</code> flag to false.</li> <li>Pagination/chunking: Render subsets to keep output readable and memory   usage low.</li> <li><code>lazy_end=True</code>: Omit the right border and right-trim cell content from   the right-most cells to reduce wasted memory from right filled spaces.</li> <li><code>separate_rows=True</code>: Add horizontal dividers between rows to improve   readability of dense data.</li> <li>Auto-fill columns: Use one or more <code>A</code> flags in column definitions to   absorb extra width when <code>table_width</code> is set.</li> <li>Preprocessing: Prefer preprocessors to normalize data early (affects   sizing) and avoid heavy transformations after formatting.</li> <li>Column filtering: Use adapter <code>columns=[...]</code> parameters to load only   needed columns from the source.</li> </ul>"},{"location":"references/","title":"API Reference","text":"<p>This section provides comprehensive API documentation for craftable, including functions, classes, styles, and exceptions.</p>"},{"location":"references/#core-functions","title":"Core Functions","text":"<p>Functions \u2014 Primary table generation functions</p> <p>Complete API documentation for the main functions used to generate and export tables:</p> <ul> <li><code>get_table()</code> \u2014 Generate a complete formatted table as a string</li> <li><code>export_table()</code> \u2014 Render and optionally write tables to files</li> <li><code>get_table_row()</code> \u2014 Generate a single formatted table row</li> <li><code>get_table_header()</code> \u2014 Generate just the header section of a table</li> </ul>"},{"location":"references/#data-structures","title":"Data Structures","text":"<p>Classes \u2014 Column definition classes</p> <p>Documentation for classes used to configure column formatting and behavior:</p> <ul> <li><code>ColDef</code> \u2014 Column definition class for controlling width, alignment, formatting, and more</li> <li><code>ColDefList</code> \u2014 Collection of column definitions with automatic sizing and adjustment methods</li> </ul>"},{"location":"references/#error-handling","title":"Error Handling","text":"<p>Exceptions \u2014 Custom exceptions</p> <p>Documentation for exceptions that may be raised during table generation:</p> <ul> <li><code>InvalidTableError</code> \u2014 Raised when table structure or configuration is invalid</li> <li><code>InvalidColDefError</code> \u2014 Raised when column definition format is invalid</li> </ul>"},{"location":"references/#styles","title":"Styles","text":""},{"location":"references/#text-output-styles","title":"Text Output Styles","text":"<p>Text Styles \u2014 Styles for terminal and text output</p> <p>Documentation for built-in styles that generate text-based table output for terminals, logs, and plain text files:</p> <ul> <li><code>NoBorderScreenStyle</code> \u2014 Minimal, compact style with no borders (default)</li> <li><code>BasicScreenStyle</code> \u2014 Classic box-drawing characters with borders</li> <li><code>RoundedBorderScreenStyle</code> \u2014 Modern rounded corners with Unicode characters</li> <li><code>MarkdownStyle</code> \u2014 GitHub-flavored Markdown table format</li> <li><code>ASCIIStyle</code> \u2014 7-bit ASCII compatible characters for maximum compatibility</li> <li><code>TableStyle</code> \u2014 Base class for creating custom text-based styles</li> <li><code>BoxChars</code> \u2014 Helper class for defining box-drawing character sets</li> </ul>"},{"location":"references/#document-export-styles","title":"Document Export Styles","text":"<p>Document Styles \u2014 Styles for document file formats</p> <p>Documentation for styles that export tables to common document formats:</p> <ul> <li><code>DocxStyle</code> \u2014 Microsoft Word (.docx) document format</li> <li><code>XlsxStyle</code> \u2014 Microsoft Excel (.xlsx) spreadsheet format with native type support</li> <li><code>OdtStyle</code> \u2014 OpenDocument Text (.odt) format</li> <li><code>OdsStyle</code> \u2014 OpenDocument Spreadsheet (.ods) format with native type support</li> <li><code>RtfStyle</code> \u2014 Rich Text Format (.rtf) for universal document compatibility</li> </ul> <p>These document styles support features like native numeric types, date handling, and format-specific styling options.</p>"},{"location":"references/classes/","title":"Classes","text":""},{"location":"references/classes/#craftable.ColDef","title":"<code>craftable.ColDef</code>  <code>dataclass</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>@dataclass\nclass ColDef:\n    width: int = 0\n    align: str = \"&lt;\"\n    prefix: str = \"\"\n    prefix_align: str = \"&gt;\"\n    suffix: str = \"\"\n    suffix_align: str = \"&lt;\"\n    auto_fill: bool = False\n    truncate: bool = False\n    strict: bool = False\n    format_spec: FormatSpec | None = None\n    preprocessor: PreprocessorCallback | None = None\n    postprocessor: PostprocessorCallback | None = None\n    none_text: str = \"\"\n\n    def set_width(self, value: int) -&gt; None:\n        self.width = value\n        if self.format_spec:\n            if self.prefix_align == \"&lt;\" or self.suffix_align == \"&gt;\":\n                adj_width = value - len(self.prefix) - len(self.suffix)\n                if adj_width &gt; 0:\n                    self.format_spec.width = adj_width\n\n    def format(self, value: Any) -&gt; str:\n        # \"Inner\" format\n        if self.format_spec:\n            format_string = f\"{{:{self.format_spec}}}\"\n        else:\n            format_string = \"{}\"\n\n        # convert None to user-configurable text\n        val = value if value is not None else self.none_text\n        try:\n            text = format_string.format(val)\n        except:  # noqa: E722\n            # On failure, fall back to string unless strict mode\n            if self.strict:\n                raise\n            else:\n                text = str(val)\n        # add prefix and suffix if there is a value\n        if value is not None:\n            text = f\"{self.prefix}{text}{self.suffix}\"\n\n        # \"Outer\" format\n        return self.format_text(text)\n\n    # ------------------------------------------------------------------\n    # Processor helpers\n    # ------------------------------------------------------------------\n    def preprocess(self, value: Any, row: list[Any], col_idx: int) -&gt; Any:\n        \"\"\"Apply the column's preprocessor callback if present.\n\n        Swallows exceptions and returns the original value on failure.\n        \"\"\"\n        if self.preprocessor and callable(self.preprocessor):\n            try:\n                return self.preprocessor(value, row, col_idx)\n            except Exception:\n                return value\n        return value\n\n    def postprocess(\n        self, original_value: Any, text: str, row: list[Any], col_idx: int\n    ) -&gt; str:\n        \"\"\"Apply the column's postprocessor callback if present.\n\n        Runs after width sizing, wrapping and alignment. Should not\n        alter the displayed width. Swallows exceptions and returns the\n        original text on failure.\n        \"\"\"\n        if self.postprocessor and callable(self.postprocessor):\n            try:\n                return self.postprocessor(original_value, text, row, col_idx)\n            except Exception:\n                return text\n        return text\n\n    def format_text(self, text: str) -&gt; str:\n        if len(text) &gt; self.width and self.truncate:\n            text = text[: self.width - 1] + \"\u2026\"\n\n        if self.align == \"^\":\n            text = text.center(self.width)\n        elif self.align == \"&gt;\":\n            text = text.rjust(self.width)\n        else:\n            text = text.ljust(self.width)\n\n        return text\n\n    @staticmethod\n    def parse(text) -&gt; \"ColDef\":\n        match = _FORMAT_SPEC_PATTERN.match(text)\n        if not match:\n            raise InvalidColDefError(f\"Invalid format specifier for column: {text}\")\n        spec = match.groupdict()\n        prefix = spec[\"prefix\"] if spec[\"prefix\"] else \"\"\n        prefix_align = spec[\"prefix_align\"] if spec[\"prefix_align\"] else \"\"\n        fill = spec[\"fill\"] if spec[\"fill\"] else \"\"\n        align = spec[\"align\"]\n        if not align or align == \"=\":\n            align = \"\"\n            fill = \"\"\n        sign = spec[\"sign\"] if spec[\"sign\"] else \"\"\n        alternate = spec[\"alternate\"] if spec[\"alternate\"] else \"\"\n        zero = spec[\"zero\"] if spec[\"zero\"] else \"\"\n        width = int(spec[\"width\"]) if spec[\"width\"] else 0\n        grouping = spec[\"grouping_option\"] if spec[\"grouping_option\"] else \"\"\n        precision = spec[\"precision\"] if spec[\"precision\"] else \"\"\n        type_ = spec[\"type\"] if spec[\"type\"] else \"\"\n        suffix_align = spec[\"suffix_align\"] if spec[\"suffix_align\"] else \"\"\n        suffix = spec[\"suffix\"] if spec[\"suffix\"] else \"\"\n\n        auto_size = False\n        truncate = False\n\n        table_config = spec[\"table_config\"]\n        if table_config:\n            if \"A\" in table_config:\n                auto_size = True\n            if \"T\" in table_config:\n                truncate = True\n\n        format_spec = FormatSpec(\n            fill=fill,\n            align=align,\n            sign=sign,\n            alternate=alternate,\n            zero=zero,\n            grouping=grouping,\n            precision=precision,\n            type=type_,\n        )\n\n        if width and (prefix_align == \"&lt;\" or suffix_align == \"&gt;\"):\n            adj_width = width - len(prefix) - len(suffix)\n            if adj_width &gt; 0:\n                format_spec.width = adj_width\n        else:\n            format_spec.align = \"\"\n\n        # if format spec is just a number, then just toss it to avoid\n        # inadvertent right-aligned numbers.\n        try:\n            _ = int(str(format_spec))\n            format_spec = None\n        except ValueError:\n            pass\n\n        return ColDef(\n            prefix=prefix,\n            prefix_align=prefix_align,\n            suffix=suffix,\n            suffix_align=suffix_align,\n            width=width,\n            align=align,\n            auto_fill=auto_size,\n            truncate=truncate,\n            format_spec=format_spec,\n        )\n</code></pre>"},{"location":"references/classes/#craftable.ColDef.align","title":"<code>align = '&lt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.auto_fill","title":"<code>auto_fill = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.format_spec","title":"<code>format_spec = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.none_text","title":"<code>none_text = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.postprocessor","title":"<code>postprocessor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.prefix","title":"<code>prefix = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.prefix_align","title":"<code>prefix_align = '&gt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.preprocessor","title":"<code>preprocessor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.strict","title":"<code>strict = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.suffix","title":"<code>suffix = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.suffix_align","title":"<code>suffix_align = '&lt;'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.truncate","title":"<code>truncate = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.width","title":"<code>width = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDef.__init__","title":"<code>__init__</code>","text":""},{"location":"references/classes/#craftable.ColDef.format","title":"<code>format</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def format(self, value: Any) -&gt; str:\n    # \"Inner\" format\n    if self.format_spec:\n        format_string = f\"{{:{self.format_spec}}}\"\n    else:\n        format_string = \"{}\"\n\n    # convert None to user-configurable text\n    val = value if value is not None else self.none_text\n    try:\n        text = format_string.format(val)\n    except:  # noqa: E722\n        # On failure, fall back to string unless strict mode\n        if self.strict:\n            raise\n        else:\n            text = str(val)\n    # add prefix and suffix if there is a value\n    if value is not None:\n        text = f\"{self.prefix}{text}{self.suffix}\"\n\n    # \"Outer\" format\n    return self.format_text(text)\n</code></pre>"},{"location":"references/classes/#craftable.ColDef.format_text","title":"<code>format_text</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def format_text(self, text: str) -&gt; str:\n    if len(text) &gt; self.width and self.truncate:\n        text = text[: self.width - 1] + \"\u2026\"\n\n    if self.align == \"^\":\n        text = text.center(self.width)\n    elif self.align == \"&gt;\":\n        text = text.rjust(self.width)\n    else:\n        text = text.ljust(self.width)\n\n    return text\n</code></pre>"},{"location":"references/classes/#craftable.ColDef.parse","title":"<code>parse</code>  <code>staticmethod</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>@staticmethod\ndef parse(text) -&gt; \"ColDef\":\n    match = _FORMAT_SPEC_PATTERN.match(text)\n    if not match:\n        raise InvalidColDefError(f\"Invalid format specifier for column: {text}\")\n    spec = match.groupdict()\n    prefix = spec[\"prefix\"] if spec[\"prefix\"] else \"\"\n    prefix_align = spec[\"prefix_align\"] if spec[\"prefix_align\"] else \"\"\n    fill = spec[\"fill\"] if spec[\"fill\"] else \"\"\n    align = spec[\"align\"]\n    if not align or align == \"=\":\n        align = \"\"\n        fill = \"\"\n    sign = spec[\"sign\"] if spec[\"sign\"] else \"\"\n    alternate = spec[\"alternate\"] if spec[\"alternate\"] else \"\"\n    zero = spec[\"zero\"] if spec[\"zero\"] else \"\"\n    width = int(spec[\"width\"]) if spec[\"width\"] else 0\n    grouping = spec[\"grouping_option\"] if spec[\"grouping_option\"] else \"\"\n    precision = spec[\"precision\"] if spec[\"precision\"] else \"\"\n    type_ = spec[\"type\"] if spec[\"type\"] else \"\"\n    suffix_align = spec[\"suffix_align\"] if spec[\"suffix_align\"] else \"\"\n    suffix = spec[\"suffix\"] if spec[\"suffix\"] else \"\"\n\n    auto_size = False\n    truncate = False\n\n    table_config = spec[\"table_config\"]\n    if table_config:\n        if \"A\" in table_config:\n            auto_size = True\n        if \"T\" in table_config:\n            truncate = True\n\n    format_spec = FormatSpec(\n        fill=fill,\n        align=align,\n        sign=sign,\n        alternate=alternate,\n        zero=zero,\n        grouping=grouping,\n        precision=precision,\n        type=type_,\n    )\n\n    if width and (prefix_align == \"&lt;\" or suffix_align == \"&gt;\"):\n        adj_width = width - len(prefix) - len(suffix)\n        if adj_width &gt; 0:\n            format_spec.width = adj_width\n    else:\n        format_spec.align = \"\"\n\n    # if format spec is just a number, then just toss it to avoid\n    # inadvertent right-aligned numbers.\n    try:\n        _ = int(str(format_spec))\n        format_spec = None\n    except ValueError:\n        pass\n\n    return ColDef(\n        prefix=prefix,\n        prefix_align=prefix_align,\n        suffix=suffix,\n        suffix_align=suffix_align,\n        width=width,\n        align=align,\n        auto_fill=auto_size,\n        truncate=truncate,\n        format_spec=format_spec,\n    )\n</code></pre>"},{"location":"references/classes/#craftable.ColDef.postprocess","title":"<code>postprocess</code>","text":"<p>Apply the column's postprocessor callback if present.</p> <p>Runs after width sizing, wrapping and alignment. Should not alter the displayed width. Swallows exceptions and returns the original text on failure.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>def postprocess(\n    self, original_value: Any, text: str, row: list[Any], col_idx: int\n) -&gt; str:\n    \"\"\"Apply the column's postprocessor callback if present.\n\n    Runs after width sizing, wrapping and alignment. Should not\n    alter the displayed width. Swallows exceptions and returns the\n    original text on failure.\n    \"\"\"\n    if self.postprocessor and callable(self.postprocessor):\n        try:\n            return self.postprocessor(original_value, text, row, col_idx)\n        except Exception:\n            return text\n    return text\n</code></pre>"},{"location":"references/classes/#craftable.ColDef.preprocess","title":"<code>preprocess</code>","text":"<p>Apply the column's preprocessor callback if present.</p> <p>Swallows exceptions and returns the original value on failure.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>def preprocess(self, value: Any, row: list[Any], col_idx: int) -&gt; Any:\n    \"\"\"Apply the column's preprocessor callback if present.\n\n    Swallows exceptions and returns the original value on failure.\n    \"\"\"\n    if self.preprocessor and callable(self.preprocessor):\n        try:\n            return self.preprocessor(value, row, col_idx)\n        except Exception:\n            return value\n    return value\n</code></pre>"},{"location":"references/classes/#craftable.ColDef.set_width","title":"<code>set_width</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def set_width(self, value: int) -&gt; None:\n    self.width = value\n    if self.format_spec:\n        if self.prefix_align == \"&lt;\" or self.suffix_align == \"&gt;\":\n            adj_width = value - len(self.prefix) - len(self.suffix)\n            if adj_width &gt; 0:\n                self.format_spec.width = adj_width\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList","title":"<code>craftable.ColDefList</code>","text":"<p>               Bases: <code>list[ColDef]</code></p> <p>A list of ColDef objects.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>class ColDefList(list[ColDef]):\n    \"\"\"\n    A list of ColDef objects.\n    \"\"\"\n\n    def __init__(self, iterable: Iterable = []):\n        super().__init__()\n        for val in iterable:\n            self.append(val)\n        self._adjusted = False\n        self._cached_list = None\n\n    @overload\n    def __setitem__(self, key: SupportsIndex, value: str | ColDef, /) -&gt; None: ...\n\n    @overload\n    def __setitem__(self, key: slice, value: Iterable[str | ColDef], /) -&gt; None: ...\n\n    def __setitem__(self, key, value):\n        if isinstance(key, SupportsIndex):\n            if isinstance(value, str):\n                super().__setitem__(key, ColDef.parse(value))\n            elif isinstance(value, ColDef):\n                super().__setitem__(key, value)\n            else:\n                raise ValueError(\"Column definition contain an invalid value\")\n        elif isinstance(key, slice) and isinstance(value, Iterable):\n            values = ColDefList(value)\n            super().__setitem__(key, values)\n        else:\n            raise ValueError(\"Column definitions contain an invalid value\")\n\n    @overload\n    def __getitem__(self, i: SupportsIndex) -&gt; ColDef: ...\n\n    @overload\n    def __getitem__(self, i: slice) -&gt; \"ColDefList\": ...\n\n    def __getitem__(self, i):\n        result = super().__getitem__(i)\n        if isinstance(i, slice):\n            return ColDefList(result)\n        else:\n            return result\n\n    def __iter__(self) -&gt; Iterator[ColDef]:\n        return super().__iter__()\n\n    def append(self, object):\n        if isinstance(object, str):\n            super().append(ColDef.parse(object))\n        elif isinstance(object, ColDef):\n            super().append(object)\n        else:\n            raise ValueError(\"Column definitions contain an invalid value\")\n\n    def as_list(self, clear_cache: bool = False) -&gt; list[ColDef]:\n        \"\"\"\n        Convert to a native list and cache it for performance.\n        Returns cached list to avoid repeated __getitem__ overhead.\n        \"\"\"\n        if self._cached_list is None or clear_cache:\n            self._cached_list = list(self)\n        return self._cached_list\n\n    @staticmethod\n    def parse(specs: Iterable[str]) -&gt; \"ColDefList\":\n        \"\"\"Parse a list of format spec strings into a ColDefList.\n\n        This is a convenience for building per-column definitions from\n        plain strings. Each spec is parsed via ColDef.parse().\n\n        Example:\n            specs = [\"A\", \"&gt;8.2f\", \"^10\"]\n            col_defs = ColDefList.parse(specs)\n\n        Args:\n            specs: Iterable of column definition strings.\n\n        Returns:\n            ColDefList: A list-like collection of ColDef objects.\n        \"\"\"\n        col_defs = ColDefList()\n        for s in specs:\n            col_defs.append(ColDef.parse(s))\n        return col_defs\n\n    def adjust_to_table(\n        self,\n        table_data: list[list[Any]],\n        table_width: int,\n        style: TableStyle,\n        has_header: bool = False,\n        clear_cache: bool = False,\n    ) -&gt; None:\n        # Skip if already adjusted\n        if self._adjusted and not clear_cache:\n            return\n        self._adjusted = True\n\n        # ADD MISSING COL DEFS\n        max_cols = max([len(row) for row in table_data])\n        diff = max_cols - len(self)\n        if diff:\n            for _ in range(diff):\n                self.append(ColDef())\n\n        # ADJUST WIDTHS OF FIELDS TO MATCH REALITY\n        for col_idx in range(max_cols):\n            col_def = self[col_idx]\n            if not col_def.width:\n                max_width = 0\n                is_header = has_header\n                for row in table_data:\n                    if is_header:\n                        is_header = False\n                        cell = str(row[col_idx])\n                    else:\n                        value = col_def.preprocess(row[col_idx], row, col_idx)\n                        cell = col_def.format(value)\n                    max_width = max(max_width, len(cell))\n\n                col_def.set_width(max_width)\n\n            if col_def.width &lt; style.min_width:\n                col_def.set_width(style.min_width)\n\n        # ADJUST AUTO-FILL COLS TO FILL REMAINING SPACE AVAILABLE IN TOTAL TABLE_WIDTH\n        if not table_width:\n            return\n\n        padding_len = style.cell_padding * 2 * len(self)\n        border_len = len(str(style.values_left)) + len(str(style.values_right))\n        delims_len = len(str(style.values_delimiter)) * (len(self) - 1)\n        non_text_len = padding_len + border_len + delims_len\n        total_len = non_text_len + sum([c.width for c in self])\n\n        fill_cols = [col_idx for col_idx in range(len(self)) if self[col_idx].auto_fill]\n        if not fill_cols:\n            if total_len &lt;= table_width:\n                return\n            else:\n                largest_col = self[0]\n                largest_col_idx = 0\n                for col_idx in range(1, len(self)):\n                    col_def = self[col_idx]\n                    if col_def.width &gt; largest_col.width:\n                        largest_col = col_def\n                        largest_col_idx = col_idx\n                largest_col.auto_fill = True\n                fill_cols.append(largest_col_idx)\n\n        fixed_len = sum([c.width for c in self if not c.auto_fill])\n\n        remaining_width = table_width - fixed_len - non_text_len\n        fill_width = remaining_width // len(fill_cols)\n\n        if fill_width &lt; style.min_width:\n            raise ValueError(\n                \"Unable to expand columns to fit table width because existing columns are too wide\"\n            )\n\n        remainder = remaining_width % len(fill_cols)\n        for col_idx in fill_cols:\n            new_width = fill_width\n            if remainder:\n                new_width += 1\n                remainder -= 1\n            self[col_idx].set_width(new_width)\n\n    @staticmethod\n    def assert_valid_table(table: Any) -&gt; None:\n        if not isinstance(table, list):\n            raise ValueError(\"Table data must be a list of rows\")\n        for row in table:\n            if not isinstance(row, list):\n                raise ValueError(\"Each row in a table must be a list of cells\")\n\n    @staticmethod\n    def for_table(table: list[list[Any]]) -&gt; \"ColDefList\":\n        ColDefList.assert_valid_table(table)\n        max_cols = max([len(row) for row in table])\n        col_defs = ColDefList([ColDef() for _ in range(max_cols)])\n        return col_defs\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList._adjusted","title":"<code>_adjusted = False</code>  <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDefList._cached_list","title":"<code>_cached_list = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/classes/#craftable.ColDefList.__getitem__","title":"<code>__getitem__</code>","text":"<pre><code>__getitem__\n</code></pre><pre><code>__getitem__\n</code></pre> Source code in <code>src/craftable/craftable.py</code> <pre><code>def __getitem__(self, i):\n    result = super().__getitem__(i)\n    if isinstance(i, slice):\n        return ColDefList(result)\n    else:\n        return result\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.__init__","title":"<code>__init__</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def __init__(self, iterable: Iterable = []):\n    super().__init__()\n    for val in iterable:\n        self.append(val)\n    self._adjusted = False\n    self._cached_list = None\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.__iter__","title":"<code>__iter__</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def __iter__(self) -&gt; Iterator[ColDef]:\n    return super().__iter__()\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.__setitem__","title":"<code>__setitem__</code>","text":"<pre><code>__setitem__\n</code></pre><pre><code>__setitem__\n</code></pre> Source code in <code>src/craftable/craftable.py</code> <pre><code>def __setitem__(self, key, value):\n    if isinstance(key, SupportsIndex):\n        if isinstance(value, str):\n            super().__setitem__(key, ColDef.parse(value))\n        elif isinstance(value, ColDef):\n            super().__setitem__(key, value)\n        else:\n            raise ValueError(\"Column definition contain an invalid value\")\n    elif isinstance(key, slice) and isinstance(value, Iterable):\n        values = ColDefList(value)\n        super().__setitem__(key, values)\n    else:\n        raise ValueError(\"Column definitions contain an invalid value\")\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.adjust_to_table","title":"<code>adjust_to_table</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def adjust_to_table(\n    self,\n    table_data: list[list[Any]],\n    table_width: int,\n    style: TableStyle,\n    has_header: bool = False,\n    clear_cache: bool = False,\n) -&gt; None:\n    # Skip if already adjusted\n    if self._adjusted and not clear_cache:\n        return\n    self._adjusted = True\n\n    # ADD MISSING COL DEFS\n    max_cols = max([len(row) for row in table_data])\n    diff = max_cols - len(self)\n    if diff:\n        for _ in range(diff):\n            self.append(ColDef())\n\n    # ADJUST WIDTHS OF FIELDS TO MATCH REALITY\n    for col_idx in range(max_cols):\n        col_def = self[col_idx]\n        if not col_def.width:\n            max_width = 0\n            is_header = has_header\n            for row in table_data:\n                if is_header:\n                    is_header = False\n                    cell = str(row[col_idx])\n                else:\n                    value = col_def.preprocess(row[col_idx], row, col_idx)\n                    cell = col_def.format(value)\n                max_width = max(max_width, len(cell))\n\n            col_def.set_width(max_width)\n\n        if col_def.width &lt; style.min_width:\n            col_def.set_width(style.min_width)\n\n    # ADJUST AUTO-FILL COLS TO FILL REMAINING SPACE AVAILABLE IN TOTAL TABLE_WIDTH\n    if not table_width:\n        return\n\n    padding_len = style.cell_padding * 2 * len(self)\n    border_len = len(str(style.values_left)) + len(str(style.values_right))\n    delims_len = len(str(style.values_delimiter)) * (len(self) - 1)\n    non_text_len = padding_len + border_len + delims_len\n    total_len = non_text_len + sum([c.width for c in self])\n\n    fill_cols = [col_idx for col_idx in range(len(self)) if self[col_idx].auto_fill]\n    if not fill_cols:\n        if total_len &lt;= table_width:\n            return\n        else:\n            largest_col = self[0]\n            largest_col_idx = 0\n            for col_idx in range(1, len(self)):\n                col_def = self[col_idx]\n                if col_def.width &gt; largest_col.width:\n                    largest_col = col_def\n                    largest_col_idx = col_idx\n            largest_col.auto_fill = True\n            fill_cols.append(largest_col_idx)\n\n    fixed_len = sum([c.width for c in self if not c.auto_fill])\n\n    remaining_width = table_width - fixed_len - non_text_len\n    fill_width = remaining_width // len(fill_cols)\n\n    if fill_width &lt; style.min_width:\n        raise ValueError(\n            \"Unable to expand columns to fit table width because existing columns are too wide\"\n        )\n\n    remainder = remaining_width % len(fill_cols)\n    for col_idx in fill_cols:\n        new_width = fill_width\n        if remainder:\n            new_width += 1\n            remainder -= 1\n        self[col_idx].set_width(new_width)\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.append","title":"<code>append</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>def append(self, object):\n    if isinstance(object, str):\n        super().append(ColDef.parse(object))\n    elif isinstance(object, ColDef):\n        super().append(object)\n    else:\n        raise ValueError(\"Column definitions contain an invalid value\")\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.as_list","title":"<code>as_list</code>","text":"<p>Convert to a native list and cache it for performance. Returns cached list to avoid repeated getitem overhead.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>def as_list(self, clear_cache: bool = False) -&gt; list[ColDef]:\n    \"\"\"\n    Convert to a native list and cache it for performance.\n    Returns cached list to avoid repeated __getitem__ overhead.\n    \"\"\"\n    if self._cached_list is None or clear_cache:\n        self._cached_list = list(self)\n    return self._cached_list\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.assert_valid_table","title":"<code>assert_valid_table</code>  <code>staticmethod</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>@staticmethod\ndef assert_valid_table(table: Any) -&gt; None:\n    if not isinstance(table, list):\n        raise ValueError(\"Table data must be a list of rows\")\n    for row in table:\n        if not isinstance(row, list):\n            raise ValueError(\"Each row in a table must be a list of cells\")\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.for_table","title":"<code>for_table</code>  <code>staticmethod</code>","text":"Source code in <code>src/craftable/craftable.py</code> <pre><code>@staticmethod\ndef for_table(table: list[list[Any]]) -&gt; \"ColDefList\":\n    ColDefList.assert_valid_table(table)\n    max_cols = max([len(row) for row in table])\n    col_defs = ColDefList([ColDef() for _ in range(max_cols)])\n    return col_defs\n</code></pre>"},{"location":"references/classes/#craftable.ColDefList.parse","title":"<code>parse</code>  <code>staticmethod</code>","text":"<p>Parse a list of format spec strings into a ColDefList.</p> <p>This is a convenience for building per-column definitions from plain strings. Each spec is parsed via ColDef.parse().</p> Example <p>specs = [\"A\", \"&gt;8.2f\", \"^10\"] col_defs = ColDefList.parse(specs)</p> <p>Parameters:</p> Name Type Description Default <code>specs</code> <code>Iterable[str]</code> <p>Iterable of column definition strings.</p> required <p>Returns:</p> Name Type Description <code>ColDefList</code> <code>ColDefList</code> <p>A list-like collection of ColDef objects.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>@staticmethod\ndef parse(specs: Iterable[str]) -&gt; \"ColDefList\":\n    \"\"\"Parse a list of format spec strings into a ColDefList.\n\n    This is a convenience for building per-column definitions from\n    plain strings. Each spec is parsed via ColDef.parse().\n\n    Example:\n        specs = [\"A\", \"&gt;8.2f\", \"^10\"]\n        col_defs = ColDefList.parse(specs)\n\n    Args:\n        specs: Iterable of column definition strings.\n\n    Returns:\n        ColDefList: A list-like collection of ColDef objects.\n    \"\"\"\n    col_defs = ColDefList()\n    for s in specs:\n        col_defs.append(ColDef.parse(s))\n    return col_defs\n</code></pre>"},{"location":"references/doc_styles/","title":"Document Styles","text":""},{"location":"references/doc_styles/#craftable.styles.DocxStyle","title":"<code>craftable.styles.DocxStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> Source code in <code>src/craftable/styles/docx_style.py</code> <pre><code>class DocxStyle(TableStyle):\n    def __init__(self, table_style: str | None = \"Light List\"):\n        super().__init__()\n        self.terminal_style = False\n        self.string_output = False  # Binary format\n        self.table_style_name = table_style\n\n    ###############################################################################\n    # write_table\n    ###############################################################################\n\n    def write_table(\n        self,\n        value_rows: list[list[Any]],\n        header_row: list[str] | None,\n        col_defs: \"ColDefList\",\n        header_defs: \"ColDefList | None\",\n        file: str | Path | IO[bytes],\n    ) -&gt; None:\n        \"\"\"Write table to DOCX file format.\"\"\"\n        try:\n            from docx import Document  # type: ignore\n            from docx.enum.text import WD_ALIGN_PARAGRAPH  # type: ignore\n            from docx.shared import Inches  # type: ignore\n        except Exception as e:  # pragma: no cover - only hit without optional dep\n            raise ImportError(\n                \"python-docx is required for DocxStyle; install group 'docx'\"\n            ) from e\n\n        doc = Document()\n\n        # Create table: rows = header + data\n        n_rows = len(value_rows) + (1 if header_row else 0)\n        n_cols = len(col_defs)\n        table = doc.add_table(\n            rows=n_rows if n_rows else 1, cols=n_cols if n_cols else 1\n        )\n        if self.table_style_name:\n            try:\n                table.style = self.table_style_name\n            except Exception:\n                # Silently ignore style setting if not available\n                pass\n\n        # Set column widths based on ColDef widths\n        # Approximate: 1 character ~ 0.12 inches at 11pt\n        for c, col_def in enumerate(col_defs):\n            if c &lt; len(table.columns):\n                char_width = max(col_def.width, 1)\n                table.columns[c].width = Inches(char_width * 0.12)\n\n        # Write header row\n        row_idx = 0\n        if header_row:\n            hdr_cells = table.rows[row_idx].cells\n            for j, text in enumerate(header_row):\n                if j &gt;= len(hdr_cells):\n                    break\n                p = hdr_cells[j].paragraphs[0]\n                # Clear any existing content and add a bold run\n                p.clear()\n                run = p.add_run(str(text))\n                run.bold = True\n                # Use alignment from header_defs if available, else center\n                if header_defs and j &lt; len(header_defs):\n                    hdr_def = header_defs[j]\n                    if \"&gt;\" in hdr_def.align:\n                        p.alignment = WD_ALIGN_PARAGRAPH.RIGHT\n                    elif \"^\" in hdr_def.align:\n                        p.alignment = WD_ALIGN_PARAGRAPH.CENTER\n                    else:\n                        p.alignment = WD_ALIGN_PARAGRAPH.LEFT\n                else:\n                    p.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            row_idx += 1\n\n        # Helper for formatting with preprocess/postprocess\n        def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n            v2 = cd.preprocess(val, row, col_idx)\n            try:\n                if v2 is None:\n                    text = cd.prefix + (cd.none_text or \"\") + cd.suffix\n                elif cd.format_spec:\n                    fmt = f\"{{:{cd.format_spec}}}\"\n                    text = cd.prefix + fmt.format(v2) + cd.suffix\n                else:\n                    text = cd.prefix + str(v2) + cd.suffix\n            except Exception:\n                text = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n            return cd.postprocess(val, text, row, col_idx)\n\n        # Write data rows\n        for r, row in enumerate(value_rows):\n            cells = table.rows[row_idx].cells\n            for c, (val, col_def) in enumerate(zip(row, col_defs)):\n                if c &gt;= len(cells):\n                    break\n                p = cells[c].paragraphs[0]\n                p.clear()\n                run = p.add_run(_format_for_export(col_def, val, row, c))\n                # Align mapping\n                if \"&gt;\" in col_def.align:\n                    p.alignment = WD_ALIGN_PARAGRAPH.RIGHT\n                elif \"^\" in col_def.align:\n                    p.alignment = WD_ALIGN_PARAGRAPH.CENTER\n                else:\n                    p.alignment = WD_ALIGN_PARAGRAPH.LEFT\n            row_idx += 1\n\n        # Save (coerce Path to str for python-docx type expectations)\n        save_target = str(file) if isinstance(file, Path) else file\n        doc.save(save_target)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.DocxStyle.write_table","title":"<code>write_table</code>","text":"<p>Write table to DOCX file format.</p> Source code in <code>src/craftable/styles/docx_style.py</code> <pre><code>def write_table(\n    self,\n    value_rows: list[list[Any]],\n    header_row: list[str] | None,\n    col_defs: \"ColDefList\",\n    header_defs: \"ColDefList | None\",\n    file: str | Path | IO[bytes],\n) -&gt; None:\n    \"\"\"Write table to DOCX file format.\"\"\"\n    try:\n        from docx import Document  # type: ignore\n        from docx.enum.text import WD_ALIGN_PARAGRAPH  # type: ignore\n        from docx.shared import Inches  # type: ignore\n    except Exception as e:  # pragma: no cover - only hit without optional dep\n        raise ImportError(\n            \"python-docx is required for DocxStyle; install group 'docx'\"\n        ) from e\n\n    doc = Document()\n\n    # Create table: rows = header + data\n    n_rows = len(value_rows) + (1 if header_row else 0)\n    n_cols = len(col_defs)\n    table = doc.add_table(\n        rows=n_rows if n_rows else 1, cols=n_cols if n_cols else 1\n    )\n    if self.table_style_name:\n        try:\n            table.style = self.table_style_name\n        except Exception:\n            # Silently ignore style setting if not available\n            pass\n\n    # Set column widths based on ColDef widths\n    # Approximate: 1 character ~ 0.12 inches at 11pt\n    for c, col_def in enumerate(col_defs):\n        if c &lt; len(table.columns):\n            char_width = max(col_def.width, 1)\n            table.columns[c].width = Inches(char_width * 0.12)\n\n    # Write header row\n    row_idx = 0\n    if header_row:\n        hdr_cells = table.rows[row_idx].cells\n        for j, text in enumerate(header_row):\n            if j &gt;= len(hdr_cells):\n                break\n            p = hdr_cells[j].paragraphs[0]\n            # Clear any existing content and add a bold run\n            p.clear()\n            run = p.add_run(str(text))\n            run.bold = True\n            # Use alignment from header_defs if available, else center\n            if header_defs and j &lt; len(header_defs):\n                hdr_def = header_defs[j]\n                if \"&gt;\" in hdr_def.align:\n                    p.alignment = WD_ALIGN_PARAGRAPH.RIGHT\n                elif \"^\" in hdr_def.align:\n                    p.alignment = WD_ALIGN_PARAGRAPH.CENTER\n                else:\n                    p.alignment = WD_ALIGN_PARAGRAPH.LEFT\n            else:\n                p.alignment = WD_ALIGN_PARAGRAPH.CENTER\n        row_idx += 1\n\n    # Helper for formatting with preprocess/postprocess\n    def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n        v2 = cd.preprocess(val, row, col_idx)\n        try:\n            if v2 is None:\n                text = cd.prefix + (cd.none_text or \"\") + cd.suffix\n            elif cd.format_spec:\n                fmt = f\"{{:{cd.format_spec}}}\"\n                text = cd.prefix + fmt.format(v2) + cd.suffix\n            else:\n                text = cd.prefix + str(v2) + cd.suffix\n        except Exception:\n            text = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n        return cd.postprocess(val, text, row, col_idx)\n\n    # Write data rows\n    for r, row in enumerate(value_rows):\n        cells = table.rows[row_idx].cells\n        for c, (val, col_def) in enumerate(zip(row, col_defs)):\n            if c &gt;= len(cells):\n                break\n            p = cells[c].paragraphs[0]\n            p.clear()\n            run = p.add_run(_format_for_export(col_def, val, row, c))\n            # Align mapping\n            if \"&gt;\" in col_def.align:\n                p.alignment = WD_ALIGN_PARAGRAPH.RIGHT\n            elif \"^\" in col_def.align:\n                p.alignment = WD_ALIGN_PARAGRAPH.CENTER\n            else:\n                p.alignment = WD_ALIGN_PARAGRAPH.LEFT\n        row_idx += 1\n\n    # Save (coerce Path to str for python-docx type expectations)\n    save_target = str(file) if isinstance(file, Path) else file\n    doc.save(save_target)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.XlsxStyle","title":"<code>craftable.styles.XlsxStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> Source code in <code>src/craftable/styles/xlsx_style.py</code> <pre><code>class XlsxStyle(TableStyle):\n    def __init__(self, sheet_name: str = \"Sheet1\"):\n        super().__init__()\n        self.terminal_style = False\n        self.string_output = False  # Binary format\n        self.sheet_name = sheet_name\n\n    ###############################################################################\n    # write_table\n    ###############################################################################\n\n    def write_table(\n        self,\n        value_rows: list[list[Any]],\n        header_row: list[str] | None,\n        col_defs: \"ColDefList\",\n        header_defs: \"ColDefList | None\",\n        file: str | Path | IO[bytes],\n    ) -&gt; None:\n        \"\"\"Write table to XLSX file format.\"\"\"\n        try:\n            from openpyxl import Workbook  # type: ignore\n            from openpyxl.utils import get_column_letter  # type: ignore\n            from openpyxl.styles import Alignment, Font  # type: ignore\n        except Exception as e:  # pragma: no cover - only hit without optional dep\n            raise ImportError(\n                \"openpyxl is required for XlsxStyle; install group 'xlsx'\"\n            ) from e\n\n        wb = Workbook()\n        ws: Any = wb.active  # type: ignore[assignment]\n        ws.title = self.sheet_name\n\n        # Write header row\n        row_idx = 1\n        if header_row:\n            for col_idx, text in enumerate(header_row, start=1):\n                cell = ws.cell(row=row_idx, column=col_idx, value=str(text))\n                cell.font = Font(bold=True)\n                # Use alignment from header_defs if available, else center\n                if header_defs and (col_idx - 1) &lt; len(header_defs):\n                    hdr_def = header_defs[col_idx - 1]\n                    if \"&gt;\" in hdr_def.align:\n                        cell.alignment = Alignment(horizontal=\"right\")\n                    elif \"^\" in hdr_def.align:\n                        cell.alignment = Alignment(horizontal=\"center\")\n                    else:\n                        cell.alignment = Alignment(horizontal=\"left\")\n                else:\n                    cell.alignment = Alignment(horizontal=\"center\")\n            row_idx += 1\n\n        # Helper for converting format specs to Excel number formats\n        def _to_excel_number_format(fmt_spec_obj) -&gt; str | None:\n            \"\"\"Map FormatSpec or string to Excel number format.\n\n            Supports:\n            - Float with precision and grouping: .2f, ,.2f -&gt; 0.00, #,##0.00\n            - Integer with grouping: d, ,d -&gt; 0, #,##0\n            - Percentage with precision: .2%, % -&gt; 0.00%, 0%\n\n            Returns None if unsupported or if fmt_spec_obj is None.\n            \"\"\"\n            if fmt_spec_obj is None:\n                return None\n\n            # Handle FormatSpec objects by extracting relevant fields\n            if hasattr(fmt_spec_obj, \"type\"):\n                type_char = fmt_spec_obj.type\n                has_group = fmt_spec_obj.grouping == \",\"\n                precision_str = fmt_spec_obj.precision\n\n                # Parse precision (e.g., \".2\" -&gt; 2)\n                decimals = 0\n                if precision_str and precision_str.startswith(\".\"):\n                    try:\n                        decimals = int(precision_str[1:])\n                    except (ValueError, IndexError):\n                        decimals = 0\n\n                if type_char == \"f\":\n                    base = \"#,##0\" if has_group else \"0\"\n                    if decimals:\n                        base += \".\" + (\"0\" * decimals)\n                    return base\n                elif type_char == \"d\":\n                    return \"#,##0\" if has_group else \"0\"\n                elif type_char == \"%\":\n                    base = \"0\" if decimals == 0 else \"0.\" + (\"0\" * decimals)\n                    return base + \"%\"\n                return None\n\n            # Fallback: parse string representation\n            if not isinstance(fmt_spec_obj, str):\n                fmt_spec_obj = str(fmt_spec_obj)\n\n            spec = fmt_spec_obj.strip().lstrip(\"&lt;&gt;^\")\n            if spec.endswith(\"f\"):\n                parts = spec[:-1].split(\".\")\n                decimals = 0\n                if len(parts) == 2 and parts[1].isdigit():\n                    decimals = int(parts[1])\n                has_group = \",\" in parts[0]\n                base = \"#,##0\" if has_group else \"0\"\n                if decimals:\n                    base += \".\" + (\"0\" * decimals)\n                return base\n            if spec.endswith(\"d\"):\n                has_group = \",\" in spec[:-1]\n                return \"#,##0\" if has_group else \"0\"\n            if spec.endswith(\"%\"):\n                # Extract precision before %\n                decimals = 0\n                if \".%\" in spec:\n                    # Pattern like \".2%\"\n                    parts = spec.split(\".\")\n                    if len(parts) &gt;= 2:\n                        num_part = parts[1].rstrip(\"%\")\n                        if num_part.isdigit():\n                            decimals = int(num_part)\n                base = \"0\" if decimals == 0 else \"0.\" + (\"0\" * decimals)\n                return base + \"%\"\n            return None\n\n        # Helper for formatting cell values with preprocess/postprocess\n        def _coerce_cell_value(\n            cd, original: Any, row: list[Any], col_idx: int\n        ) -&gt; tuple[Any, str | None]:\n            \"\"\"Return (value_for_cell, excel_number_format).\n            Falls back to formatted text when numeric coercion not safe.\n            \"\"\"\n            v2 = cd.preprocess(original, row, col_idx)\n            if v2 is None:\n                return \"\", None\n            # If prefix/suffix/postprocessor present we treat as text\n            if cd.prefix or cd.suffix or cd.postprocessor is not None:\n                try:\n                    if cd.format_spec:\n                        fmt = f\"{{:{cd.format_spec}}}\"\n                        text = fmt.format(v2)\n                    else:\n                        text = str(v2)\n                except Exception:\n                    text = str(v2)\n                text = cd.prefix + text + cd.suffix\n                return cd.postprocess(original, text, row, col_idx), None\n            # Direct acceptable python types\n            if isinstance(v2, (bool, int, float, date, datetime)):\n                nf = _to_excel_number_format(cd.format_spec) if cd.format_spec else None\n                return v2, nf\n            # Try to parse strings into numbers\n            if isinstance(v2, str):\n                txt = v2.strip().replace(\",\", \"\")\n                try:\n                    if \".\" in txt:\n                        num = float(txt)\n                        nf = (\n                            _to_excel_number_format(cd.format_spec)\n                            if cd.format_spec\n                            else None\n                        )\n                        return num, nf\n                    num = int(txt)\n                    nf = (\n                        _to_excel_number_format(cd.format_spec)\n                        if cd.format_spec\n                        else None\n                    )\n                    return num, nf\n                except Exception:\n                    pass\n            # Fallback to formatted text\n            try:\n                if cd.format_spec:\n                    fmt = f\"{{:{cd.format_spec}}}\"\n                    text = fmt.format(v2)\n                else:\n                    text = str(v2)\n            except Exception:\n                text = str(v2)\n            text = cd.prefix + text + cd.suffix\n            text = cd.postprocess(original, text, row, col_idx)\n            return text, None\n\n        # Write data rows\n        for r, row in enumerate(value_rows):\n            for c, (val, col_def) in enumerate(zip(row, col_defs), start=1):\n                cell_value, number_format = _coerce_cell_value(col_def, val, row, c - 1)\n                cell = ws.cell(row=row_idx, column=c, value=cell_value)\n                if number_format:\n                    try:\n                        cell.number_format = number_format\n                        if isinstance(cell.value, int) and \".\" in number_format:\n                            cell.value = float(cell.value)\n                    except Exception:\n                        pass\n                if \"&gt;\" in col_def.align:\n                    cell.alignment = Alignment(horizontal=\"right\")\n                elif \"^\" in col_def.align:\n                    cell.alignment = Alignment(horizontal=\"center\")\n                else:\n                    cell.alignment = Alignment(horizontal=\"left\")\n            row_idx += 1\n\n        # Set column widths based on ColDef widths\n        # Excel width units are approximately character widths at default font\n        # Add small padding for better visual appearance\n        for c, col_def in enumerate(col_defs, start=1):\n            letter = get_column_letter(c)\n            char_width = max(col_def.width, 1)\n            # Excel width formula: slightly wider than character count for padding\n            ws.column_dimensions[letter].width = char_width + 2\n\n        wb.save(file)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.XlsxStyle.write_table","title":"<code>write_table</code>","text":"<p>Write table to XLSX file format.</p> Source code in <code>src/craftable/styles/xlsx_style.py</code> <pre><code>def write_table(\n    self,\n    value_rows: list[list[Any]],\n    header_row: list[str] | None,\n    col_defs: \"ColDefList\",\n    header_defs: \"ColDefList | None\",\n    file: str | Path | IO[bytes],\n) -&gt; None:\n    \"\"\"Write table to XLSX file format.\"\"\"\n    try:\n        from openpyxl import Workbook  # type: ignore\n        from openpyxl.utils import get_column_letter  # type: ignore\n        from openpyxl.styles import Alignment, Font  # type: ignore\n    except Exception as e:  # pragma: no cover - only hit without optional dep\n        raise ImportError(\n            \"openpyxl is required for XlsxStyle; install group 'xlsx'\"\n        ) from e\n\n    wb = Workbook()\n    ws: Any = wb.active  # type: ignore[assignment]\n    ws.title = self.sheet_name\n\n    # Write header row\n    row_idx = 1\n    if header_row:\n        for col_idx, text in enumerate(header_row, start=1):\n            cell = ws.cell(row=row_idx, column=col_idx, value=str(text))\n            cell.font = Font(bold=True)\n            # Use alignment from header_defs if available, else center\n            if header_defs and (col_idx - 1) &lt; len(header_defs):\n                hdr_def = header_defs[col_idx - 1]\n                if \"&gt;\" in hdr_def.align:\n                    cell.alignment = Alignment(horizontal=\"right\")\n                elif \"^\" in hdr_def.align:\n                    cell.alignment = Alignment(horizontal=\"center\")\n                else:\n                    cell.alignment = Alignment(horizontal=\"left\")\n            else:\n                cell.alignment = Alignment(horizontal=\"center\")\n        row_idx += 1\n\n    # Helper for converting format specs to Excel number formats\n    def _to_excel_number_format(fmt_spec_obj) -&gt; str | None:\n        \"\"\"Map FormatSpec or string to Excel number format.\n\n        Supports:\n        - Float with precision and grouping: .2f, ,.2f -&gt; 0.00, #,##0.00\n        - Integer with grouping: d, ,d -&gt; 0, #,##0\n        - Percentage with precision: .2%, % -&gt; 0.00%, 0%\n\n        Returns None if unsupported or if fmt_spec_obj is None.\n        \"\"\"\n        if fmt_spec_obj is None:\n            return None\n\n        # Handle FormatSpec objects by extracting relevant fields\n        if hasattr(fmt_spec_obj, \"type\"):\n            type_char = fmt_spec_obj.type\n            has_group = fmt_spec_obj.grouping == \",\"\n            precision_str = fmt_spec_obj.precision\n\n            # Parse precision (e.g., \".2\" -&gt; 2)\n            decimals = 0\n            if precision_str and precision_str.startswith(\".\"):\n                try:\n                    decimals = int(precision_str[1:])\n                except (ValueError, IndexError):\n                    decimals = 0\n\n            if type_char == \"f\":\n                base = \"#,##0\" if has_group else \"0\"\n                if decimals:\n                    base += \".\" + (\"0\" * decimals)\n                return base\n            elif type_char == \"d\":\n                return \"#,##0\" if has_group else \"0\"\n            elif type_char == \"%\":\n                base = \"0\" if decimals == 0 else \"0.\" + (\"0\" * decimals)\n                return base + \"%\"\n            return None\n\n        # Fallback: parse string representation\n        if not isinstance(fmt_spec_obj, str):\n            fmt_spec_obj = str(fmt_spec_obj)\n\n        spec = fmt_spec_obj.strip().lstrip(\"&lt;&gt;^\")\n        if spec.endswith(\"f\"):\n            parts = spec[:-1].split(\".\")\n            decimals = 0\n            if len(parts) == 2 and parts[1].isdigit():\n                decimals = int(parts[1])\n            has_group = \",\" in parts[0]\n            base = \"#,##0\" if has_group else \"0\"\n            if decimals:\n                base += \".\" + (\"0\" * decimals)\n            return base\n        if spec.endswith(\"d\"):\n            has_group = \",\" in spec[:-1]\n            return \"#,##0\" if has_group else \"0\"\n        if spec.endswith(\"%\"):\n            # Extract precision before %\n            decimals = 0\n            if \".%\" in spec:\n                # Pattern like \".2%\"\n                parts = spec.split(\".\")\n                if len(parts) &gt;= 2:\n                    num_part = parts[1].rstrip(\"%\")\n                    if num_part.isdigit():\n                        decimals = int(num_part)\n            base = \"0\" if decimals == 0 else \"0.\" + (\"0\" * decimals)\n            return base + \"%\"\n        return None\n\n    # Helper for formatting cell values with preprocess/postprocess\n    def _coerce_cell_value(\n        cd, original: Any, row: list[Any], col_idx: int\n    ) -&gt; tuple[Any, str | None]:\n        \"\"\"Return (value_for_cell, excel_number_format).\n        Falls back to formatted text when numeric coercion not safe.\n        \"\"\"\n        v2 = cd.preprocess(original, row, col_idx)\n        if v2 is None:\n            return \"\", None\n        # If prefix/suffix/postprocessor present we treat as text\n        if cd.prefix or cd.suffix or cd.postprocessor is not None:\n            try:\n                if cd.format_spec:\n                    fmt = f\"{{:{cd.format_spec}}}\"\n                    text = fmt.format(v2)\n                else:\n                    text = str(v2)\n            except Exception:\n                text = str(v2)\n            text = cd.prefix + text + cd.suffix\n            return cd.postprocess(original, text, row, col_idx), None\n        # Direct acceptable python types\n        if isinstance(v2, (bool, int, float, date, datetime)):\n            nf = _to_excel_number_format(cd.format_spec) if cd.format_spec else None\n            return v2, nf\n        # Try to parse strings into numbers\n        if isinstance(v2, str):\n            txt = v2.strip().replace(\",\", \"\")\n            try:\n                if \".\" in txt:\n                    num = float(txt)\n                    nf = (\n                        _to_excel_number_format(cd.format_spec)\n                        if cd.format_spec\n                        else None\n                    )\n                    return num, nf\n                num = int(txt)\n                nf = (\n                    _to_excel_number_format(cd.format_spec)\n                    if cd.format_spec\n                    else None\n                )\n                return num, nf\n            except Exception:\n                pass\n        # Fallback to formatted text\n        try:\n            if cd.format_spec:\n                fmt = f\"{{:{cd.format_spec}}}\"\n                text = fmt.format(v2)\n            else:\n                text = str(v2)\n        except Exception:\n            text = str(v2)\n        text = cd.prefix + text + cd.suffix\n        text = cd.postprocess(original, text, row, col_idx)\n        return text, None\n\n    # Write data rows\n    for r, row in enumerate(value_rows):\n        for c, (val, col_def) in enumerate(zip(row, col_defs), start=1):\n            cell_value, number_format = _coerce_cell_value(col_def, val, row, c - 1)\n            cell = ws.cell(row=row_idx, column=c, value=cell_value)\n            if number_format:\n                try:\n                    cell.number_format = number_format\n                    if isinstance(cell.value, int) and \".\" in number_format:\n                        cell.value = float(cell.value)\n                except Exception:\n                    pass\n            if \"&gt;\" in col_def.align:\n                cell.alignment = Alignment(horizontal=\"right\")\n            elif \"^\" in col_def.align:\n                cell.alignment = Alignment(horizontal=\"center\")\n            else:\n                cell.alignment = Alignment(horizontal=\"left\")\n        row_idx += 1\n\n    # Set column widths based on ColDef widths\n    # Excel width units are approximately character widths at default font\n    # Add small padding for better visual appearance\n    for c, col_def in enumerate(col_defs, start=1):\n        letter = get_column_letter(c)\n        char_width = max(col_def.width, 1)\n        # Excel width formula: slightly wider than character count for padding\n        ws.column_dimensions[letter].width = char_width + 2\n\n    wb.save(file)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.OdtStyle","title":"<code>craftable.styles.OdtStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> Source code in <code>src/craftable/styles/odt_style.py</code> <pre><code>class OdtStyle(TableStyle):\n    def __init__(self):\n        super().__init__()\n        self.terminal_style = False\n        self.string_output = False  # Binary format\n\n    ###############################################################################\n    # write_table\n    ###############################################################################\n\n    def write_table(\n        self,\n        value_rows: list[list[Any]],\n        header_row: list[str] | None,\n        col_defs: \"ColDefList\",\n        header_defs: \"ColDefList | None\",\n        file: str | Path | IO[bytes],\n    ) -&gt; None:\n        \"\"\"Write table to ODT file format.\"\"\"\n        try:\n            from odf.opendocument import OpenDocumentText  # type: ignore\n            from odf import table, text  # type: ignore\n        except Exception as e:  # pragma: no cover - only hit without optional dep\n            raise ImportError(\n                \"odfpy is required for OdtStyle; install group 'odt'\"\n            ) from e\n\n        doc = OpenDocumentText()\n\n        # Define paragraph styles\n        from odf.style import Style, TextProperties, ParagraphProperties  # type: ignore\n\n        odf_table = table.Table(name=\"Table1\")\n\n        # Define alignment styles\n        left_style = Style(name=\"LeftAlign\", family=\"paragraph\")\n        left_style.addElement(ParagraphProperties(textalign=\"left\"))\n        doc.automaticstyles.addElement(left_style)\n\n        center_style = Style(name=\"CenterAlign\", family=\"paragraph\")\n        center_style.addElement(ParagraphProperties(textalign=\"center\"))\n        doc.automaticstyles.addElement(center_style)\n\n        right_style = Style(name=\"RightAlign\", family=\"paragraph\")\n        right_style.addElement(ParagraphProperties(textalign=\"right\"))\n        doc.automaticstyles.addElement(right_style)\n\n        # Bold styles for headers\n        header_bold_left = Style(name=\"HeaderBoldLeft\", family=\"paragraph\")\n        header_bold_left.addElement(TextProperties(fontweight=\"bold\"))\n        header_bold_left.addElement(ParagraphProperties(textalign=\"left\"))\n        doc.automaticstyles.addElement(header_bold_left)\n\n        header_bold_center = Style(name=\"HeaderBoldCenter\", family=\"paragraph\")\n        header_bold_center.addElement(TextProperties(fontweight=\"bold\"))\n        header_bold_center.addElement(ParagraphProperties(textalign=\"center\"))\n        doc.automaticstyles.addElement(header_bold_center)\n\n        header_bold_right = Style(name=\"HeaderBoldRight\", family=\"paragraph\")\n        header_bold_right.addElement(TextProperties(fontweight=\"bold\"))\n        header_bold_right.addElement(ParagraphProperties(textalign=\"right\"))\n        doc.automaticstyles.addElement(header_bold_right)\n\n        # Write header row with proper alignment\n        if header_row:\n            hdr_row = table.TableRow()\n            for i, header in enumerate(header_row):\n                cell = table.TableCell()\n                # Use header_defs for alignment if provided\n                if header_defs and i &lt; len(header_defs):\n                    hdr_def = header_defs[i]\n                    if hdr_def.align == \"&gt;\":\n                        p = text.P(stylename=header_bold_right, text=str(header))\n                    elif hdr_def.align == \"^\":\n                        p = text.P(stylename=header_bold_center, text=str(header))\n                    else:  # Left or default\n                        p = text.P(stylename=header_bold_left, text=str(header))\n                else:\n                    # Default to centered bold\n                    p = text.P(stylename=header_bold_center, text=str(header))\n                cell.addElement(p)\n                hdr_row.addElement(cell)\n                odf_table.addElement(hdr_row)\n\n        # Helper for formatting with preprocess/postprocess\n        def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n            v2 = cd.preprocess(val, row, col_idx)\n            try:\n                if v2 is None:\n                    s = cd.prefix + (cd.none_text or \"\") + cd.suffix\n                elif cd.format_spec:\n                    fmt = f\"{{:{cd.format_spec}}}\"\n                    s = cd.prefix + fmt.format(v2) + cd.suffix\n                else:\n                    s = cd.prefix + str(v2) + cd.suffix\n            except Exception:\n                s = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n            return cd.postprocess(val, s, row, col_idx)\n\n        # Write data rows\n        for row in value_rows:\n            tr = table.TableRow()\n            for i, (val, col_def) in enumerate(zip(row, col_defs)):\n                tc = table.TableCell()\n                # Map ColDef alignment to paragraph style\n                if \"&gt;\" in col_def.align:\n                    style = right_style\n                elif \"^\" in col_def.align:\n                    style = center_style\n                else:\n                    style = left_style\n                p = text.P(\n                    stylename=style, text=_format_for_export(col_def, val, row, i)\n                )\n                tc.addElement(p)\n                tr.addElement(tc)\n            odf_table.addElement(tr)\n\n        doc.text.addElement(odf_table)\n\n        # Save (OpenDocumentText.save accepts filename or file-like)\n        doc.save(file)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.OdtStyle.write_table","title":"<code>write_table</code>","text":"<p>Write table to ODT file format.</p> Source code in <code>src/craftable/styles/odt_style.py</code> <pre><code>def write_table(\n    self,\n    value_rows: list[list[Any]],\n    header_row: list[str] | None,\n    col_defs: \"ColDefList\",\n    header_defs: \"ColDefList | None\",\n    file: str | Path | IO[bytes],\n) -&gt; None:\n    \"\"\"Write table to ODT file format.\"\"\"\n    try:\n        from odf.opendocument import OpenDocumentText  # type: ignore\n        from odf import table, text  # type: ignore\n    except Exception as e:  # pragma: no cover - only hit without optional dep\n        raise ImportError(\n            \"odfpy is required for OdtStyle; install group 'odt'\"\n        ) from e\n\n    doc = OpenDocumentText()\n\n    # Define paragraph styles\n    from odf.style import Style, TextProperties, ParagraphProperties  # type: ignore\n\n    odf_table = table.Table(name=\"Table1\")\n\n    # Define alignment styles\n    left_style = Style(name=\"LeftAlign\", family=\"paragraph\")\n    left_style.addElement(ParagraphProperties(textalign=\"left\"))\n    doc.automaticstyles.addElement(left_style)\n\n    center_style = Style(name=\"CenterAlign\", family=\"paragraph\")\n    center_style.addElement(ParagraphProperties(textalign=\"center\"))\n    doc.automaticstyles.addElement(center_style)\n\n    right_style = Style(name=\"RightAlign\", family=\"paragraph\")\n    right_style.addElement(ParagraphProperties(textalign=\"right\"))\n    doc.automaticstyles.addElement(right_style)\n\n    # Bold styles for headers\n    header_bold_left = Style(name=\"HeaderBoldLeft\", family=\"paragraph\")\n    header_bold_left.addElement(TextProperties(fontweight=\"bold\"))\n    header_bold_left.addElement(ParagraphProperties(textalign=\"left\"))\n    doc.automaticstyles.addElement(header_bold_left)\n\n    header_bold_center = Style(name=\"HeaderBoldCenter\", family=\"paragraph\")\n    header_bold_center.addElement(TextProperties(fontweight=\"bold\"))\n    header_bold_center.addElement(ParagraphProperties(textalign=\"center\"))\n    doc.automaticstyles.addElement(header_bold_center)\n\n    header_bold_right = Style(name=\"HeaderBoldRight\", family=\"paragraph\")\n    header_bold_right.addElement(TextProperties(fontweight=\"bold\"))\n    header_bold_right.addElement(ParagraphProperties(textalign=\"right\"))\n    doc.automaticstyles.addElement(header_bold_right)\n\n    # Write header row with proper alignment\n    if header_row:\n        hdr_row = table.TableRow()\n        for i, header in enumerate(header_row):\n            cell = table.TableCell()\n            # Use header_defs for alignment if provided\n            if header_defs and i &lt; len(header_defs):\n                hdr_def = header_defs[i]\n                if hdr_def.align == \"&gt;\":\n                    p = text.P(stylename=header_bold_right, text=str(header))\n                elif hdr_def.align == \"^\":\n                    p = text.P(stylename=header_bold_center, text=str(header))\n                else:  # Left or default\n                    p = text.P(stylename=header_bold_left, text=str(header))\n            else:\n                # Default to centered bold\n                p = text.P(stylename=header_bold_center, text=str(header))\n            cell.addElement(p)\n            hdr_row.addElement(cell)\n            odf_table.addElement(hdr_row)\n\n    # Helper for formatting with preprocess/postprocess\n    def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n        v2 = cd.preprocess(val, row, col_idx)\n        try:\n            if v2 is None:\n                s = cd.prefix + (cd.none_text or \"\") + cd.suffix\n            elif cd.format_spec:\n                fmt = f\"{{:{cd.format_spec}}}\"\n                s = cd.prefix + fmt.format(v2) + cd.suffix\n            else:\n                s = cd.prefix + str(v2) + cd.suffix\n        except Exception:\n            s = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n        return cd.postprocess(val, s, row, col_idx)\n\n    # Write data rows\n    for row in value_rows:\n        tr = table.TableRow()\n        for i, (val, col_def) in enumerate(zip(row, col_defs)):\n            tc = table.TableCell()\n            # Map ColDef alignment to paragraph style\n            if \"&gt;\" in col_def.align:\n                style = right_style\n            elif \"^\" in col_def.align:\n                style = center_style\n            else:\n                style = left_style\n            p = text.P(\n                stylename=style, text=_format_for_export(col_def, val, row, i)\n            )\n            tc.addElement(p)\n            tr.addElement(tc)\n        odf_table.addElement(tr)\n\n    doc.text.addElement(odf_table)\n\n    # Save (OpenDocumentText.save accepts filename or file-like)\n    doc.save(file)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.OdsStyle","title":"<code>craftable.styles.OdsStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> Source code in <code>src/craftable/styles/ods_style.py</code> <pre><code>class OdsStyle(TableStyle):\n    def __init__(self, sheet_name: str = \"Sheet1\"):\n        super().__init__()\n        self.terminal_style = False\n        self.string_output = False  # Binary format\n        self.sheet_name = sheet_name\n\n    ###############################################################################\n    # write_table\n    ###############################################################################\n\n    def write_table(\n        self,\n        value_rows: list[list[Any]],\n        header_row: list[str] | None,\n        col_defs: \"ColDefList\",\n        header_defs: \"ColDefList | None\",\n        file: str | Path | IO[bytes],\n    ) -&gt; None:\n        \"\"\"Write table to ODS file format.\"\"\"\n        try:\n            from odf.opendocument import OpenDocumentSpreadsheet  # type: ignore\n            from odf import table, text  # type: ignore\n        except Exception as e:  # pragma: no cover - only hit without optional dep\n            raise ImportError(\n                \"odfpy is required for OdsStyle; install group 'ods'\"\n            ) from e\n\n        doc = OpenDocumentSpreadsheet()\n\n        # Define paragraph styles\n        from odf.style import Style, TextProperties, ParagraphProperties  # type: ignore\n\n        left_style = Style(name=\"LeftAlign\", family=\"paragraph\")\n        left_style.addElement(ParagraphProperties(textalign=\"left\"))\n        doc.automaticstyles.addElement(left_style)\n\n        center_style = Style(name=\"CenterAlign\", family=\"paragraph\")\n        center_style.addElement(ParagraphProperties(textalign=\"center\"))\n        doc.automaticstyles.addElement(center_style)\n\n        right_style = Style(name=\"RightAlign\", family=\"paragraph\")\n        right_style.addElement(ParagraphProperties(textalign=\"right\"))\n        doc.automaticstyles.addElement(right_style)\n\n        # Bold styles for headers\n        header_bold_left = Style(name=\"HeaderBoldLeft\", family=\"paragraph\")\n        header_bold_left.addElement(TextProperties(fontweight=\"bold\"))\n        header_bold_left.addElement(ParagraphProperties(textalign=\"left\"))\n        doc.automaticstyles.addElement(header_bold_left)\n\n        header_bold_center = Style(name=\"HeaderBoldCenter\", family=\"paragraph\")\n        header_bold_center.addElement(TextProperties(fontweight=\"bold\"))\n        header_bold_center.addElement(ParagraphProperties(textalign=\"center\"))\n        doc.automaticstyles.addElement(header_bold_center)\n\n        header_bold_right = Style(name=\"HeaderBoldRight\", family=\"paragraph\")\n        header_bold_right.addElement(TextProperties(fontweight=\"bold\"))\n        header_bold_right.addElement(ParagraphProperties(textalign=\"right\"))\n        doc.automaticstyles.addElement(header_bold_right)\n\n        sheet = table.Table(name=self.sheet_name)\n\n        # Write header row\n        if header_row:\n            tr = table.TableRow()\n            for i, h in enumerate(header_row):\n                tc = table.TableCell()\n                # Determine style based on header_defs alignment\n                style_to_use = header_bold_center\n                if header_defs and i &lt; len(header_defs):\n                    hdr_def = header_defs[i]\n                    if \"&gt;\" in hdr_def.align:\n                        style_to_use = header_bold_right\n                    elif \"&lt;\" in hdr_def.align:\n                        style_to_use = header_bold_left\n                    # Center alignment uses header_bold_center (already bold)\n                p = text.P(stylename=style_to_use, text=str(h))\n                tc.addElement(p)\n                tr.addElement(tc)\n            sheet.addElement(tr)\n\n        # Helper for formatting with preprocess/postprocess\n        def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n            v2 = cd.preprocess(val, row, col_idx)\n            try:\n                if v2 is None:\n                    s = cd.prefix + (cd.none_text or \"\") + cd.suffix\n                elif cd.format_spec:\n                    fmt = f\"{{:{cd.format_spec}}}\"\n                    s = cd.prefix + fmt.format(v2) + cd.suffix\n                else:\n                    s = cd.prefix + str(v2) + cd.suffix\n            except Exception:\n                s = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n            return cd.postprocess(val, s, row, col_idx)\n\n        # Write data rows\n        for row in value_rows:\n            tr = table.TableRow()\n            for i, (val, col_def) in enumerate(zip(row, col_defs)):\n                # Prepare value (respect preprocess / postprocess similar to XLSX)\n                v2 = col_def.preprocess(val, row, i)\n                is_text_mode = (\n                    col_def.prefix\n                    or col_def.suffix\n                    or col_def.postprocessor is not None\n                )\n                tc_kwargs: dict[str, str] = {}\n                cell_text: str\n                if v2 is None:\n                    cell_text = (\n                        col_def.prefix + (col_def.none_text or \"\") + col_def.suffix\n                    )\n                # Check boolean FIRST since bool is subclass of int in Python\n                elif (not is_text_mode) and isinstance(v2, bool):\n                    tc_kwargs = {\n                        \"valuetype\": \"boolean\",\n                        \"value\": \"true\" if v2 else \"false\",\n                    }\n                    cell_text = \"true\" if v2 else \"false\"\n                elif (not is_text_mode) and isinstance(v2, (date, datetime)):\n                    # ODF date value\n                    iso_val = v2.isoformat()\n                    tc_kwargs = {\"valuetype\": \"date\", \"datevalue\": iso_val}\n                    cell_text = iso_val\n                elif (not is_text_mode) and isinstance(v2, (int, float)):\n                    # Check if format spec indicates percentage\n                    is_percent = (\n                        col_def.format_spec\n                        and hasattr(col_def.format_spec, \"type\")\n                        and col_def.format_spec.type == \"%\"\n                    )\n                    if is_percent:\n                        tc_kwargs = {\"valuetype\": \"percentage\", \"value\": str(v2)}\n                        cell_text = str(v2)\n                    else:\n                        tc_kwargs = {\"valuetype\": \"float\", \"value\": str(v2)}\n                        cell_text = str(v2)\n                else:\n                    try:\n                        if col_def.format_spec:\n                            fmt = f\"{{:{col_def.format_spec}}}\"\n                            cell_text = fmt.format(v2)\n                        else:\n                            cell_text = str(v2)\n                    except Exception:\n                        cell_text = str(v2)\n                    cell_text = col_def.prefix + cell_text + col_def.suffix\n                # Apply postprocessor if any\n                if col_def.postprocessor is not None:\n                    cell_text = col_def.postprocessor(val, cell_text, row, i)\n                tc = table.TableCell(**tc_kwargs)\n                # Map ColDef alignment to paragraph style\n                if \"&gt;\" in col_def.align:\n                    style = right_style\n                elif \"^\" in col_def.align:\n                    style = center_style\n                else:\n                    style = left_style\n                p = text.P(stylename=style, text=cell_text)\n                tc.addElement(p)\n                tr.addElement(tc)\n            sheet.addElement(tr)\n\n        doc.spreadsheet.addElement(sheet)\n\n        doc.save(file)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.OdsStyle.write_table","title":"<code>write_table</code>","text":"<p>Write table to ODS file format.</p> Source code in <code>src/craftable/styles/ods_style.py</code> <pre><code>def write_table(\n    self,\n    value_rows: list[list[Any]],\n    header_row: list[str] | None,\n    col_defs: \"ColDefList\",\n    header_defs: \"ColDefList | None\",\n    file: str | Path | IO[bytes],\n) -&gt; None:\n    \"\"\"Write table to ODS file format.\"\"\"\n    try:\n        from odf.opendocument import OpenDocumentSpreadsheet  # type: ignore\n        from odf import table, text  # type: ignore\n    except Exception as e:  # pragma: no cover - only hit without optional dep\n        raise ImportError(\n            \"odfpy is required for OdsStyle; install group 'ods'\"\n        ) from e\n\n    doc = OpenDocumentSpreadsheet()\n\n    # Define paragraph styles\n    from odf.style import Style, TextProperties, ParagraphProperties  # type: ignore\n\n    left_style = Style(name=\"LeftAlign\", family=\"paragraph\")\n    left_style.addElement(ParagraphProperties(textalign=\"left\"))\n    doc.automaticstyles.addElement(left_style)\n\n    center_style = Style(name=\"CenterAlign\", family=\"paragraph\")\n    center_style.addElement(ParagraphProperties(textalign=\"center\"))\n    doc.automaticstyles.addElement(center_style)\n\n    right_style = Style(name=\"RightAlign\", family=\"paragraph\")\n    right_style.addElement(ParagraphProperties(textalign=\"right\"))\n    doc.automaticstyles.addElement(right_style)\n\n    # Bold styles for headers\n    header_bold_left = Style(name=\"HeaderBoldLeft\", family=\"paragraph\")\n    header_bold_left.addElement(TextProperties(fontweight=\"bold\"))\n    header_bold_left.addElement(ParagraphProperties(textalign=\"left\"))\n    doc.automaticstyles.addElement(header_bold_left)\n\n    header_bold_center = Style(name=\"HeaderBoldCenter\", family=\"paragraph\")\n    header_bold_center.addElement(TextProperties(fontweight=\"bold\"))\n    header_bold_center.addElement(ParagraphProperties(textalign=\"center\"))\n    doc.automaticstyles.addElement(header_bold_center)\n\n    header_bold_right = Style(name=\"HeaderBoldRight\", family=\"paragraph\")\n    header_bold_right.addElement(TextProperties(fontweight=\"bold\"))\n    header_bold_right.addElement(ParagraphProperties(textalign=\"right\"))\n    doc.automaticstyles.addElement(header_bold_right)\n\n    sheet = table.Table(name=self.sheet_name)\n\n    # Write header row\n    if header_row:\n        tr = table.TableRow()\n        for i, h in enumerate(header_row):\n            tc = table.TableCell()\n            # Determine style based on header_defs alignment\n            style_to_use = header_bold_center\n            if header_defs and i &lt; len(header_defs):\n                hdr_def = header_defs[i]\n                if \"&gt;\" in hdr_def.align:\n                    style_to_use = header_bold_right\n                elif \"&lt;\" in hdr_def.align:\n                    style_to_use = header_bold_left\n                # Center alignment uses header_bold_center (already bold)\n            p = text.P(stylename=style_to_use, text=str(h))\n            tc.addElement(p)\n            tr.addElement(tc)\n        sheet.addElement(tr)\n\n    # Helper for formatting with preprocess/postprocess\n    def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n        v2 = cd.preprocess(val, row, col_idx)\n        try:\n            if v2 is None:\n                s = cd.prefix + (cd.none_text or \"\") + cd.suffix\n            elif cd.format_spec:\n                fmt = f\"{{:{cd.format_spec}}}\"\n                s = cd.prefix + fmt.format(v2) + cd.suffix\n            else:\n                s = cd.prefix + str(v2) + cd.suffix\n        except Exception:\n            s = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n        return cd.postprocess(val, s, row, col_idx)\n\n    # Write data rows\n    for row in value_rows:\n        tr = table.TableRow()\n        for i, (val, col_def) in enumerate(zip(row, col_defs)):\n            # Prepare value (respect preprocess / postprocess similar to XLSX)\n            v2 = col_def.preprocess(val, row, i)\n            is_text_mode = (\n                col_def.prefix\n                or col_def.suffix\n                or col_def.postprocessor is not None\n            )\n            tc_kwargs: dict[str, str] = {}\n            cell_text: str\n            if v2 is None:\n                cell_text = (\n                    col_def.prefix + (col_def.none_text or \"\") + col_def.suffix\n                )\n            # Check boolean FIRST since bool is subclass of int in Python\n            elif (not is_text_mode) and isinstance(v2, bool):\n                tc_kwargs = {\n                    \"valuetype\": \"boolean\",\n                    \"value\": \"true\" if v2 else \"false\",\n                }\n                cell_text = \"true\" if v2 else \"false\"\n            elif (not is_text_mode) and isinstance(v2, (date, datetime)):\n                # ODF date value\n                iso_val = v2.isoformat()\n                tc_kwargs = {\"valuetype\": \"date\", \"datevalue\": iso_val}\n                cell_text = iso_val\n            elif (not is_text_mode) and isinstance(v2, (int, float)):\n                # Check if format spec indicates percentage\n                is_percent = (\n                    col_def.format_spec\n                    and hasattr(col_def.format_spec, \"type\")\n                    and col_def.format_spec.type == \"%\"\n                )\n                if is_percent:\n                    tc_kwargs = {\"valuetype\": \"percentage\", \"value\": str(v2)}\n                    cell_text = str(v2)\n                else:\n                    tc_kwargs = {\"valuetype\": \"float\", \"value\": str(v2)}\n                    cell_text = str(v2)\n            else:\n                try:\n                    if col_def.format_spec:\n                        fmt = f\"{{:{col_def.format_spec}}}\"\n                        cell_text = fmt.format(v2)\n                    else:\n                        cell_text = str(v2)\n                except Exception:\n                    cell_text = str(v2)\n                cell_text = col_def.prefix + cell_text + col_def.suffix\n            # Apply postprocessor if any\n            if col_def.postprocessor is not None:\n                cell_text = col_def.postprocessor(val, cell_text, row, i)\n            tc = table.TableCell(**tc_kwargs)\n            # Map ColDef alignment to paragraph style\n            if \"&gt;\" in col_def.align:\n                style = right_style\n            elif \"^\" in col_def.align:\n                style = center_style\n            else:\n                style = left_style\n            p = text.P(stylename=style, text=cell_text)\n            tc.addElement(p)\n            tr.addElement(tc)\n        sheet.addElement(tr)\n\n    doc.spreadsheet.addElement(sheet)\n\n    doc.save(file)\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.RtfStyle","title":"<code>craftable.styles.RtfStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> Source code in <code>src/craftable/styles/rtf_style.py</code> <pre><code>class RtfStyle(TableStyle):\n    def __init__(self):\n        super().__init__()\n        self.terminal_style = False\n        self.string_output = False  # RTF is not human-readable string output\n\n    ###############################################################################\n    # write_table\n    ###############################################################################\n\n    def write_table(\n        self,\n        value_rows: list[list[Any]],\n        header_row: list[str] | None,\n        col_defs: \"ColDefList\",\n        header_defs: \"ColDefList | None\",\n        file: str | Path | IO[bytes],\n    ) -&gt; None:\n        \"\"\"Write table to RTF file format.\"\"\"\n        # Render an actual RTF table using \\trowd/\\cellx/\\cell/\\row.\n        # Widths are approximated from column character widths.\n\n        def char_width_to_twips(chars: int) -&gt; int:\n            # Approximate: ~240 twips per character (roughly 12pt mono width)\n            return max(1, int(chars) * 240)\n\n        # Compute cell boundaries (\\cellx) as cumulative widths\n        cellx_positions: list[int] = []\n        x = 0\n        for cd in col_defs:\n            # Add minimal padding around text visually\n            col_twips = char_width_to_twips(max(cd.width, 1) + 2)\n            x += col_twips\n            cellx_positions.append(x)\n\n        parts: list[str] = []\n        parts.append(\"{\\\\rtf1\\\\ansi\")\n\n        def row_to_rtf(\n            cells: list[str], bold: bool = False, use_header_defs: bool = False\n        ) -&gt; None:\n            parts.append(\"\\\\trowd\\\\trgaph108\")\n            # Define cell boundaries\n            for cx in cellx_positions:\n                parts.append(f\"\\\\cellx{cx}\")\n            # Cell contents\n            for idx, text in enumerate(cells):\n                # Alignment mapping using paragraph alignment\n                # For headers, use header_defs alignment if available\n                if use_header_defs and header_defs and idx &lt; len(header_defs):\n                    hdr_def = header_defs[idx]\n                    if \"&gt;\" in hdr_def.align:\n                        align = \"\\\\qr\"\n                    elif \"^\" in hdr_def.align:\n                        align = \"\\\\qc\"\n                    else:\n                        align = \"\\\\ql\"\n                else:\n                    cd = col_defs[idx]\n                    if \"&gt;\" in cd.align:\n                        align = \"\\\\qr\"\n                    elif \"^\" in cd.align:\n                        align = \"\\\\qc\"\n                    else:\n                        align = \"\\\\ql\"\n                content = self._escape(text)\n                # Wrap in \\b ... \\b0 for header bold\n                if bold:\n                    parts.append(f\"{{\\\\intbl {align} \\\\b {content} \\\\b0 \\\\cell}}\")\n                else:\n                    parts.append(f\"{{\\\\intbl {align} {content} \\\\cell}}\")\n            parts.append(\"\\\\row\")\n\n        # Write header row\n        if header_row:\n            row_to_rtf([str(h) for h in header_row], bold=True, use_header_defs=True)\n\n        # Helper for formatting with preprocess/postprocess\n        def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n            v2 = cd.preprocess(val, row, col_idx)\n            try:\n                if v2 is None:\n                    s = cd.prefix + (cd.none_text or \"\") + cd.suffix\n                elif cd.format_spec:\n                    fmt = f\"{{:{cd.format_spec}}}\"\n                    s = cd.prefix + fmt.format(v2) + cd.suffix\n                else:\n                    s = cd.prefix + str(v2) + cd.suffix\n            except Exception:\n                s = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n            return cd.postprocess(val, s, row, col_idx)\n\n        # Write data rows\n        for row in value_rows:\n            formatted = [\n                _format_for_export(cd, v, row, i)\n                for i, (v, cd) in enumerate(zip(row, col_defs))\n            ]\n            row_to_rtf(formatted, bold=False)\n\n        parts.append(\"}\")\n        rtf_content = \"\".join(parts)\n\n        # Write to file\n        if isinstance(file, (str, Path)):\n            with open(file, \"w\", encoding=\"utf-8\") as f:\n                f.write(rtf_content)\n        else:\n            # Assume file-like object\n            file.write(rtf_content)  # type: ignore[arg-type]\n\n    def _escape(self, text: str) -&gt; str:\n        # Escape backslashes and braces for RTF\n        return text.replace(\"\\\\\", \"\\\\\\\\\").replace(\"{\", \"\\\\{\").replace(\"}\", \"\\\\}\")\n</code></pre>"},{"location":"references/doc_styles/#craftable.styles.RtfStyle.write_table","title":"<code>write_table</code>","text":"<p>Write table to RTF file format.</p> Source code in <code>src/craftable/styles/rtf_style.py</code> <pre><code>def write_table(\n    self,\n    value_rows: list[list[Any]],\n    header_row: list[str] | None,\n    col_defs: \"ColDefList\",\n    header_defs: \"ColDefList | None\",\n    file: str | Path | IO[bytes],\n) -&gt; None:\n    \"\"\"Write table to RTF file format.\"\"\"\n    # Render an actual RTF table using \\trowd/\\cellx/\\cell/\\row.\n    # Widths are approximated from column character widths.\n\n    def char_width_to_twips(chars: int) -&gt; int:\n        # Approximate: ~240 twips per character (roughly 12pt mono width)\n        return max(1, int(chars) * 240)\n\n    # Compute cell boundaries (\\cellx) as cumulative widths\n    cellx_positions: list[int] = []\n    x = 0\n    for cd in col_defs:\n        # Add minimal padding around text visually\n        col_twips = char_width_to_twips(max(cd.width, 1) + 2)\n        x += col_twips\n        cellx_positions.append(x)\n\n    parts: list[str] = []\n    parts.append(\"{\\\\rtf1\\\\ansi\")\n\n    def row_to_rtf(\n        cells: list[str], bold: bool = False, use_header_defs: bool = False\n    ) -&gt; None:\n        parts.append(\"\\\\trowd\\\\trgaph108\")\n        # Define cell boundaries\n        for cx in cellx_positions:\n            parts.append(f\"\\\\cellx{cx}\")\n        # Cell contents\n        for idx, text in enumerate(cells):\n            # Alignment mapping using paragraph alignment\n            # For headers, use header_defs alignment if available\n            if use_header_defs and header_defs and idx &lt; len(header_defs):\n                hdr_def = header_defs[idx]\n                if \"&gt;\" in hdr_def.align:\n                    align = \"\\\\qr\"\n                elif \"^\" in hdr_def.align:\n                    align = \"\\\\qc\"\n                else:\n                    align = \"\\\\ql\"\n            else:\n                cd = col_defs[idx]\n                if \"&gt;\" in cd.align:\n                    align = \"\\\\qr\"\n                elif \"^\" in cd.align:\n                    align = \"\\\\qc\"\n                else:\n                    align = \"\\\\ql\"\n            content = self._escape(text)\n            # Wrap in \\b ... \\b0 for header bold\n            if bold:\n                parts.append(f\"{{\\\\intbl {align} \\\\b {content} \\\\b0 \\\\cell}}\")\n            else:\n                parts.append(f\"{{\\\\intbl {align} {content} \\\\cell}}\")\n        parts.append(\"\\\\row\")\n\n    # Write header row\n    if header_row:\n        row_to_rtf([str(h) for h in header_row], bold=True, use_header_defs=True)\n\n    # Helper for formatting with preprocess/postprocess\n    def _format_for_export(cd, val, row: list[Any], col_idx: int) -&gt; str:\n        v2 = cd.preprocess(val, row, col_idx)\n        try:\n            if v2 is None:\n                s = cd.prefix + (cd.none_text or \"\") + cd.suffix\n            elif cd.format_spec:\n                fmt = f\"{{:{cd.format_spec}}}\"\n                s = cd.prefix + fmt.format(v2) + cd.suffix\n            else:\n                s = cd.prefix + str(v2) + cd.suffix\n        except Exception:\n            s = cd.prefix + (cd.none_text if v2 is None else str(v2)) + cd.suffix\n        return cd.postprocess(val, s, row, col_idx)\n\n    # Write data rows\n    for row in value_rows:\n        formatted = [\n            _format_for_export(cd, v, row, i)\n            for i, (v, cd) in enumerate(zip(row, col_defs))\n        ]\n        row_to_rtf(formatted, bold=False)\n\n    parts.append(\"}\")\n    rtf_content = \"\".join(parts)\n\n    # Write to file\n    if isinstance(file, (str, Path)):\n        with open(file, \"w\", encoding=\"utf-8\") as f:\n            f.write(rtf_content)\n    else:\n        # Assume file-like object\n        file.write(rtf_content)  # type: ignore[arg-type]\n</code></pre>"},{"location":"references/exceptions/","title":"Exceptions","text":""},{"location":"references/exceptions/#craftable.InvalidTableError","title":"<code>craftable.InvalidTableError</code>","text":"<p>               Bases: <code>ValueError</code></p> Source code in <code>src/craftable/craftable.py</code> <pre><code>class InvalidTableError(ValueError): ...\n</code></pre>"},{"location":"references/exceptions/#craftable.InvalidColDefError","title":"<code>craftable.InvalidColDefError</code>","text":"<p>               Bases: <code>ValueError</code></p> Source code in <code>src/craftable/craftable.py</code> <pre><code>class InvalidColDefError(ValueError): ...\n</code></pre>"},{"location":"references/functions/","title":"Functions","text":""},{"location":"references/functions/#craftable.get_table","title":"<code>craftable.get_table</code>","text":"<p>Primary function called to generate a table string.</p> <p>Parameters:</p> Name Type Description Default <code>value_rows</code> <code>Iterable[Iterable[Any]]</code> <p>A collection of rows, where each row is a collection of values. This is required. However, a default message of \"No data to display\" will be shown if the collection is empty or None.</p> required <code>header_row</code> <code>Iterable[Any] | None</code> <p>(optional) A collection of header column names. Defaults to None.</p> <code>None</code> <code>style</code> <code>TableStyle</code> <p>(optional) A TableStyle object defining the table's appearance. Defaults to NoBorderScreenStyle.</p> <code>NoBorderScreenStyle()</code> <code>col_defs</code> <code>Iterable[str] | Iterable[ColDef] | ColDefList | None</code> <p>(optional) A collection of column definitions to control width, alignment, etc. for data rows. Defaults to left aligned, auto-sized columns.</p> <code>None</code> <code>header_defs</code> <code>Iterable[str] | Iterable[ColDef] | ColDefList | None</code> <p>(optional) A collection of column definitions for the header row. If not provided, defaults to center-aligned columns with the same widths as col_defs.</p> <code>None</code> <code>table_width</code> <code>int</code> <p>(optional) Desired total width of the table. Will be automatically calculated if not specified. Defaults to 0.</p> <code>0</code> <code>lazy_end</code> <code>bool</code> <p>(optional) If True, omits the right border of the table. Defaults to False.</p> <code>False</code> <code>separate_rows</code> <code>bool</code> <p>(optional) If True, adds a separator line between each row. Defaults to False.</p> <code>False</code> <code>preprocessors</code> <code>PreprocessorCallbackList | None</code> <p>(optional) List of per-column callbacks applied before formatting and sizing. Each entry should be a callable of the form <code>fn(value, row, col_idx) -&gt; value</code>. Defaults to None.</p> <code>None</code> <code>postprocessors</code> <code>PostprocessorCallbackList | None</code> <p>(optional) List of per-column callbacks applied after formatting, sizing, and wrapping. Each entry should be a callable of the form <code>fn(original_value, text, row, col_idx) -&gt; str</code>. Defaults to None.</p> <code>None</code> <code>none_text</code> <code>str</code> <p>(optional) Text to display for None values. Defaults to empty string.</p> <code>''</code> Behavior <ul> <li>Validates that the style supports string output (raises ValueError if   not).</li> <li>If value_rows is empty, returns a table with \"No data to display\"   message.</li> <li>Converts value_rows to a list of lists for consistent processing.</li> <li>Calculates column widths based on content and table_width constraints.</li> <li>Generates column definitions (col_defs) from content if not provided.</li> <li>Generates header definitions (header_defs) from col_defs if not   provided, defaulting to center-aligned headers.</li> <li>Renders the table header if header_row is provided or   style.force_header is True.</li> <li>Renders each data row, optionally adding separator lines between rows   if separate_rows is True.</li> <li>Renders the bottom border if the style includes one.</li> <li>Applies preprocessors before formatting and postprocessors after   formatting.</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string representing the complete table, including all</p> <code>str</code> <p>borders, header, data rows, and separators as defined by the style.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>def get_table(\n    value_rows: Iterable[Iterable[Any]],\n    header_row: Iterable[Any] | None = None,\n    style: TableStyle = NoBorderScreenStyle(),\n    col_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n    header_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n    table_width: int = 0,\n    lazy_end: bool = False,\n    separate_rows: bool = False,\n    preprocessors: PreprocessorCallbackList | None = None,\n    postprocessors: PostprocessorCallbackList | None = None,\n    none_text: str = \"\",\n) -&gt; str:\n    \"\"\"\n    Primary function called to generate a table string.\n\n    Parameters:\n        value_rows:\n            A collection of rows, where each row is a collection of values. This\n            is required. However, a default message of \"No data to display\" will\n            be shown if the collection is empty or None.\n        header_row:\n            (optional) A collection of header column names. Defaults to None.\n        style:\n            (optional) A TableStyle object defining the table's appearance.\n            Defaults to NoBorderScreenStyle.\n        col_defs:\n            (optional) A collection of column definitions to control width,\n            alignment, etc. for data rows. Defaults to left aligned, auto-sized\n            columns.\n        header_defs:\n            (optional) A collection of column definitions for the header row. If\n            not provided, defaults to center-aligned columns with the same\n            widths as col_defs.\n        table_width:\n            (optional) Desired total width of the table. Will be automatically\n            calculated if not specified. Defaults to 0.\n        lazy_end:\n            (optional) If True, omits the right border of the table. Defaults to\n            False.\n        separate_rows:\n            (optional) If True, adds a separator line between each row. Defaults\n            to False.\n        preprocessors:\n            (optional) List of per-column callbacks applied before formatting\n            and sizing. Each entry should be a callable of the form\n            ``fn(value, row, col_idx) -&gt; value``. Defaults to None.\n        postprocessors:\n            (optional) List of per-column callbacks applied after formatting,\n            sizing, and wrapping. Each entry should be a callable of the form\n            ``fn(original_value, text, row, col_idx) -&gt; str``. Defaults to None.\n        none_text:\n            (optional) Text to display for None values. Defaults to empty\n            string.\n\n    Behavior:\n        - Validates that the style supports string output (raises ValueError if\n          not).\n        - If value_rows is empty, returns a table with \"No data to display\"\n          message.\n        - Converts value_rows to a list of lists for consistent processing.\n        - Calculates column widths based on content and table_width constraints.\n        - Generates column definitions (col_defs) from content if not provided.\n        - Generates header definitions (header_defs) from col_defs if not\n          provided, defaulting to center-aligned headers.\n        - Renders the table header if header_row is provided or\n          style.force_header is True.\n        - Renders each data row, optionally adding separator lines between rows\n          if separate_rows is True.\n        - Renders the bottom border if the style includes one.\n        - Applies preprocessors before formatting and postprocessors after\n          formatting.\n\n    Returns:\n        A formatted string representing the complete table, including all\n        borders, header, data rows, and separators as defined by the style.\n    \"\"\"\n    # Validate that style supports string output for get_table\n    if not getattr(style, \"string_output\", True):\n        raise ValueError(\n            f\"{style.__class__.__name__} does not support string output. \"\n            \"Use export_table() instead.\"\n        )\n\n    if not value_rows:\n        return get_table(\n            [[\"No data to display\"]],\n            style=style,\n            table_width=table_width,\n            lazy_end=lazy_end,\n        )\n\n    if not table_width and style.terminal_style:\n        table_width = get_term_width()\n\n    padding_width = 2 * style.cell_padding\n\n    # convert / copy the rows to a list of lists. Slight overhead but it helps\n    # with consistency and prevents accidentally modifying the caller's data.\n    _value_rows: list[list[Any]] = [list(row) for row in value_rows]\n    _header_row: list[Any] | None = None\n    if header_row:\n        _header_row = [str(col) for col in header_row]\n\n    # createa a second (shallow) copy to help with calculating column widths\n    all_rows = _value_rows.copy()\n    if _header_row:\n        all_rows.insert(0, _header_row)\n\n    max_cols = max(len(row) for row in all_rows)\n\n    _col_defs = _get_adjusted_col_defs(\n        all_rows=all_rows,\n        style=style,\n        col_defs=col_defs,\n        table_width=table_width,\n        preprocessors=preprocessors,\n        postprocessors=postprocessors,\n        none_text=none_text,\n    )\n\n    if not header_row and style.force_header:\n        header_row = [\"\"] * max_cols\n\n    _header_defs = _generate_header_defs(\n        header_row=_header_row,\n        header_defs=header_defs,\n        col_defs=_col_defs,\n    )\n\n    # Delegate to a custom renderer when the style provides one (e.g., HTML/LaTeX)\n    renderer = getattr(style, \"render_table\", None)\n    if callable(renderer):\n        return str(renderer(_value_rows, _header_row, _col_defs, _header_defs))\n\n    # Generate header and rows\n    output_rows = []\n    if _header_row:\n        if len(_header_row) &lt; max_cols:\n            # pad header row\n            diff = max_cols - len(_header_row)\n            _header_row.extend([\"\"] * diff)\n        row = get_table_header(\n            header_cols=_header_row,\n            style=style,\n            header_defs=_header_defs,\n            col_defs=_col_defs,\n            table_width=table_width,\n            lazy_end=lazy_end,\n        )\n        output_rows.append(row)\n    else:\n        if style.top_border:\n            line = str(style.no_header_top_line)\n            delim = str(style.no_header_top_delimiter)\n            left = str(style.no_header_top_left)\n            right = line if lazy_end else str(style.no_header_top_right)\n            border_lines = [line * (col.width + padding_width) for col in _col_defs]\n            border = delim.join(border_lines)\n            border = left + border + right\n            output_rows.append(border)\n\n    # Add Value Rows\n    rowcount = 0\n    for values in _value_rows:\n        rowcount += 1\n        lastrow = rowcount == len(_value_rows)\n        if len(values) &lt; max_cols:\n            # pad row\n            diff = max_cols - len(values)\n            values.extend([\"\"] * diff)\n        row = _get_table_row(\n            values=values,\n            style=style,\n            col_defs=_col_defs,\n            table_width=table_width,\n            lazy_end=lazy_end,\n        )\n        output_rows.append(row)\n\n        # Optionally add Separators Between Rows\n        if not lastrow and separate_rows and style.row_separator_line:\n            line = str(style.row_separator_line)\n            left = str(style.row_separator_left)\n            right = line if lazy_end else str(style.row_separator_right)\n            delim = str(style.row_separator_delimiter)\n            sep_lines = [line * (col.width + padding_width) for col in _col_defs]\n            separator = delim.join(sep_lines)\n            separator = left + separator + right\n            output_rows.append(separator)\n\n    # Add Bottom Border\n    if style.bottom_border:\n        line = str(style.values_bottom_line)\n        delim = str(style.values_bottom_delimiter)\n        left = str(style.values_bottom_left)\n        right = line if lazy_end else str(style.values_bottom_right)\n        border_lines = [line * (col.width + padding_width) for col in _col_defs]\n        border = delim.join(border_lines)\n        border = left + border + right\n        output_rows.append(border)\n\n    return \"\\n\".join(output_rows)\n</code></pre>"},{"location":"references/functions/#craftable.export_table","title":"<code>craftable.export_table</code>","text":"<p>Render the table and optionally write it to a file.</p> <p>Parameters:</p> Name Type Description Default <code>value_rows</code> <code>Iterable[Iterable[Any]]</code> <p>A collection of rows, where each row is a collection of values.</p> required <code>header_row</code> <code>Iterable[Any] | None</code> <p>(optional) A collection of header column names. Defaults to None.</p> <code>None</code> <code>style</code> <code>TableStyle</code> <p>(optional) A TableStyle object defining the table's appearance and export format. Defaults to NoBorderScreenStyle.</p> <code>NoBorderScreenStyle()</code> <code>col_defs</code> <code>Iterable[str] | Iterable[ColDef] | ColDefList | None</code> <p>(optional) A collection of column definitions to control width, alignment, formatting, etc. for data rows. Defaults to left aligned, auto-sized columns.</p> <code>None</code> <code>header_defs</code> <code>Iterable[str] | Iterable[ColDef] | ColDefList | None</code> <p>(optional) A collection of column definitions for the header row. If not provided, defaults to center-aligned columns with the same widths as col_defs. Used to control header alignment in exported files.</p> <code>None</code> <code>preprocessors</code> <code>PreprocessorCallbackList | None</code> <p>(optional) List of per-column callbacks applied before formatting and sizing. Each entry should be a callable of the form <code>fn(value, row, col_idx) -&gt; value</code>. Defaults to None.</p> <code>None</code> <code>postprocessors</code> <code>PostprocessorCallbackList | None</code> <p>(optional) List of per-column callbacks applied after formatting, sizing, and wrapping. Each entry should be a callable of the form <code>fn(original_value, text, row, col_idx) -&gt; str</code>. Defaults to None.</p> <code>None</code> <code>none_text</code> <code>str</code> <p>(optional) Text to display for None values. Defaults to empty string.</p> <code>''</code> <code>file</code> <code>str | Path | IO[str] | IO[bytes] | None</code> <p>(optional) File path (str or Path) or file-like object (IO) to write the output. If None, returns the rendered content as a string. Defaults to None.</p> <code>None</code> <code>encoding</code> <code>str</code> <p>(optional) Character encoding for text output. Only used when writing text content to a file path. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Behavior <ul> <li>If the style provides a write_table(..., file) method and a file is given,   delegate writing to the style and return the provided file path/handle.</li> <li>Else, if the style provides render_table(...), render to a string (or bytes).   If a file is provided, write it; otherwise return the rendered content.</li> <li>Else, fall back to craftable's text renderer via get_table().</li> </ul> <p>Returns:</p> Type Description <code>str | Path | None</code> <ul> <li>If file is provided as a path (str or Path), returns the file path for convenience.</li> </ul> <code>str | Path | None</code> <ul> <li>If file is a file-like object, returns None after writing.</li> </ul> <code>str | Path | None</code> <ul> <li>Otherwise, returns the rendered content as a string.</li> </ul> Source code in <code>src/craftable/craftable.py</code> <pre><code>def export_table(\n    value_rows: Iterable[Iterable[Any]],\n    header_row: Iterable[Any] | None = None,\n    style: TableStyle = NoBorderScreenStyle(),\n    col_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n    header_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n    preprocessors: PreprocessorCallbackList | None = None,\n    postprocessors: PostprocessorCallbackList | None = None,\n    none_text: str = \"\",\n    file: str | Path | IO[str] | IO[bytes] | None = None,\n    encoding: str = \"utf-8\",\n) -&gt; str | Path | None:\n    \"\"\"\n    Render the table and optionally write it to a file.\n\n    Parameters:\n        value_rows:\n            A collection of rows, where each row is a collection of values.\n        header_row:\n            (optional) A collection of header column names. Defaults to None.\n        style:\n            (optional) A TableStyle object defining the table's appearance and\n            export format. Defaults to NoBorderScreenStyle.\n        col_defs:\n            (optional) A collection of column definitions to control width,\n            alignment, formatting, etc. for data rows. Defaults to left aligned,\n            auto-sized columns.\n        header_defs:\n            (optional) A collection of column definitions for the header row. If\n            not provided, defaults to center-aligned columns with the same\n            widths as col_defs. Used to control header alignment in exported\n            files.\n        preprocessors:\n            (optional) List of per-column callbacks applied before formatting\n            and sizing. Each entry should be a callable of the form\n            ``fn(value, row, col_idx) -&gt; value``. Defaults to None.\n        postprocessors:\n            (optional) List of per-column callbacks applied after formatting,\n            sizing, and wrapping. Each entry should be a callable of the form\n            ``fn(original_value, text, row, col_idx) -&gt; str``. Defaults to None.\n        none_text:\n            (optional) Text to display for None values. Defaults to empty\n            string.\n        file:\n            (optional) File path (str or Path) or file-like object (IO) to write\n            the output. If None, returns the rendered content as a string.\n            Defaults to None.\n        encoding:\n            (optional) Character encoding for text output. Only used when\n            writing text content to a file path. Defaults to \"utf-8\".\n\n    Behavior:\n        - If the style provides a write_table(..., file) method and a file is given,\n          delegate writing to the style and return the provided file path/handle.\n        - Else, if the style provides render_table(...), render to a string (or bytes).\n          If a file is provided, write it; otherwise return the rendered content.\n        - Else, fall back to craftable's text renderer via get_table().\n\n    Returns:\n        - If file is provided as a path (str or Path), returns the file path for convenience.\n        - If file is a file-like object, returns None after writing.\n        - Otherwise, returns the rendered content as a string.\n    \"\"\"\n\n    # Normalize inputs similar to get_table()\n    _value_rows: list[list[Any]] = [list(row) for row in value_rows]\n    _header_row: list[Any] | None = None\n    if header_row:\n        _header_row = [str(col) for col in header_row]\n\n    all_rows = _value_rows.copy()\n    if _header_row:\n        all_rows.insert(0, _header_row)\n\n    _col_defs = _get_adjusted_col_defs(\n        all_rows=all_rows,\n        style=style,\n        col_defs=col_defs,\n        preprocessors=preprocessors,\n        postprocessors=postprocessors,\n        none_text=none_text,\n    )\n\n    max_cols = max(len(row) for row in all_rows)\n\n    if not header_row and style.force_header:\n        header_row = [\"\"] * max_cols\n\n    _header_defs = _generate_header_defs(\n        header_row=_header_row,\n        header_defs=header_defs,\n        col_defs=_col_defs,\n    )\n\n    # Prefer explicit writer when available\n    writer = getattr(style, \"write_table\", None)\n    if callable(writer) and file is not None:\n        writer(_value_rows, _header_row, _col_defs, _header_defs, file)\n        return Path(file) if isinstance(file, (str, Path)) else None\n\n    # Otherwise render content and optionally write\n    renderer = getattr(style, \"render_table\", None)\n    if callable(renderer):\n        content = renderer(_value_rows, _header_row, _col_defs)\n        if file is None:\n            return str(content)\n        # Decide binary vs text write\n        if isinstance(content, (bytes, bytearray)):\n            if isinstance(file, (str, Path)):\n                with open(file, \"wb\") as f:\n                    f.write(content)\n                return Path(file)\n            else:\n                # Assume binary-capable IO\n                file.write(content)  # type: ignore[arg-type]\n                return None\n        else:\n            # Text content\n            if isinstance(file, (str, Path)):\n                with open(file, \"w\", encoding=encoding) as f:\n                    f.write(str(content))\n                return Path(file)\n            else:\n                # Assume text-capable IO\n                file.write(str(content))  # type: ignore[arg-type]\n                return None\n\n    # Fallback to core text renderer\n    content = get_table(\n        value_rows,\n        header_row=header_row,\n        style=style,\n        col_defs=_col_defs,\n        header_defs=_header_defs,\n        preprocessors=preprocessors,\n        postprocessors=postprocessors,\n        none_text=none_text,\n    )\n    if file is None:\n        return content\n    if isinstance(file, (str, Path)):\n        with open(file, \"w\", encoding=encoding) as f:\n            f.write(content)\n        return Path(file)\n    else:\n        file.write(content)  # type: ignore[arg-type]\n        return None\n</code></pre>"},{"location":"references/functions/#craftable.get_table_row","title":"<code>craftable.get_table_row</code>","text":"<p>Generate a string for a single table row.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[Any]</code> <p>A list of values.</p> required <code>style</code> <code>TableStyle</code> <p>(optional) A TableStyle object defining the table's appearance. Defaults to NoBorderScreenStyle.</p> <code>NoBorderScreenStyle()</code> <code>col_defs</code> <code>list[str] | list[ColDef] | ColDefList | None</code> <p>(optional) Column definitions to control width, alignment, etc. If not provided, generates default left-aligned columns based on values.</p> <code>None</code> <code>table_width</code> <code>int</code> <p>(optional) Desired total width of the table. If 0, uses terminal width when style.terminal_style is True. Defaults to 0.</p> <code>0</code> <code>lazy_end</code> <code>bool</code> <p>(optional) If True, omits the right border of the table. Defaults to True.</p> <code>True</code> <code>preprocessors</code> <code>PreprocessorCallbackList | None</code> <p>(optional) List of per-column callbacks applied before formatting and sizing. Each entry should be a callable of the form <code>fn(value, row, col_idx) -&gt; value</code>. Defaults to None.</p> <code>None</code> <code>postprocessors</code> <code>PostprocessorCallbackList | None</code> <p>(optional) List of per-column callbacks applied after formatting, sizing, and wrapping. Each entry should be a callable of the form <code>fn(original_value, text, row, col_idx) -&gt; str</code>. Defaults to None.</p> <code>None</code> <code>none_text</code> <code>str</code> <p>(optional) Text to display for None values. Defaults to empty string.</p> <code>''</code> Behavior <ul> <li>If col_defs is not provided, generates default left-aligned column   definitions based on the values.</li> <li>Applies preprocessors to transform values before formatting.</li> <li>Formats each value according to its column definition.</li> <li>Applies postprocessors to transform formatted text.</li> <li>Renders the row using the specified table style.</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string representing a single table row, including borders</p> <code>str</code> <p>and cell padding as defined by the style.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>def get_table_row(\n    values: list[Any],\n    style: TableStyle = NoBorderScreenStyle(),\n    col_defs: list[str] | list[ColDef] | ColDefList | None = None,\n    table_width: int = 0,\n    lazy_end: bool = True,\n    preprocessors: PreprocessorCallbackList | None = None,\n    postprocessors: PostprocessorCallbackList | None = None,\n    none_text: str = \"\",\n) -&gt; str:\n    \"\"\"\n    Generate a string for a single table row.\n\n    Parameters:\n        values:\n            A list of values.\n        style:\n            (optional) A TableStyle object defining the table's appearance.\n            Defaults to NoBorderScreenStyle.\n        col_defs:\n            (optional) Column definitions to control width, alignment, etc. If\n            not provided, generates default left-aligned columns based on values.\n        table_width:\n            (optional) Desired total width of the table. If 0, uses terminal\n            width when style.terminal_style is True. Defaults to 0.\n        lazy_end:\n            (optional) If True, omits the right border of the table. Defaults\n            to True.\n        preprocessors:\n            (optional) List of per-column callbacks applied before formatting\n            and sizing. Each entry should be a callable of the form\n            ``fn(value, row, col_idx) -&gt; value``. Defaults to None.\n        postprocessors:\n            (optional) List of per-column callbacks applied after formatting,\n            sizing, and wrapping. Each entry should be a callable of the form\n            ``fn(original_value, text, row, col_idx) -&gt; str``. Defaults to None.\n        none_text:\n            (optional) Text to display for None values. Defaults to empty\n            string.\n\n    Behavior:\n        - If col_defs is not provided, generates default left-aligned column\n          definitions based on the values.\n        - Applies preprocessors to transform values before formatting.\n        - Formats each value according to its column definition.\n        - Applies postprocessors to transform formatted text.\n        - Renders the row using the specified table style.\n\n    Returns:\n        A formatted string representing a single table row, including borders\n        and cell padding as defined by the style.\n    \"\"\"\n\n    _col_defs = _get_adjusted_col_defs(\n        all_rows=[values],\n        style=style,\n        col_defs=col_defs,\n        table_width=table_width,\n        preprocessors=preprocessors,\n        postprocessors=postprocessors,\n        none_text=none_text,\n    )\n    return _get_table_row(\n        values=values,\n        style=style,\n        col_defs=_col_defs,\n        table_width=table_width,\n        lazy_end=lazy_end,\n        is_header=False,\n    )\n</code></pre>"},{"location":"references/functions/#craftable.get_table_header","title":"<code>craftable.get_table_header</code>","text":"<p>Generate a string for the header of a table.</p> <p>Parameters:</p> Name Type Description Default <code>header_cols</code> <code>list[str]</code> <p>A list of header column names.</p> required <code>style</code> <code>TableStyle</code> <p>(optional) A TableStyle object defining the table's appearance. Defaults to NoBorderScreenStyle.</p> <code>NoBorderScreenStyle()</code> <code>header_defs</code> <code>Iterable[str] | Iterable[ColDef] | ColDefList | None</code> <p>(optional) Column definitions for the header row. If not provided, defaults to column definitions generated from header_cols.</p> <code>None</code> <code>col_defs</code> <code>Iterable[str] | Iterable[ColDef] | ColDefList | None</code> <p>(optional) Column definitions for the rest of the table rows. Only required for styles that have an alignment character (e.g., Markdown). If not provided, uses the same as header_defs.</p> <code>None</code> <code>table_width</code> <code>int</code> <p>(optional) Desired total width of the table. Will be automatically calculated if not provided. Defaults to 0.</p> <code>0</code> <code>lazy_end</code> <code>bool</code> <p>(optional) If True, omits the right border of the table. Defaults to True.</p> <code>True</code> Behavior <ul> <li>If header_defs is not provided, generates default column definitions from header_cols.</li> <li>If col_defs is not provided, uses a copy of header_defs.</li> <li>Adjusts column definitions to fit the specified or calculated table width.</li> <li>Renders the top border if the style includes one.</li> <li>Renders the header row with the specified header definitions.</li> <li>Renders the bottom border (separator between header and data rows).</li> <li>For styles with alignment characters (e.g., Markdown), uses col_defs to determine   column alignment indicators in the separator line.</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string representing the table header, including top border,</p> <code>str</code> <p>header row, and header separator line as defined by the style.</p> Source code in <code>src/craftable/craftable.py</code> <pre><code>def get_table_header(\n    header_cols: list[str],\n    style: TableStyle = NoBorderScreenStyle(),\n    header_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n    col_defs: Iterable[str] | Iterable[ColDef] | ColDefList | None = None,\n    table_width: int = 0,\n    lazy_end: bool = True,\n) -&gt; str:\n    \"\"\"\n    Generate a string for the header of a table.\n\n    Parameters:\n        header_cols:\n            A list of header column names.\n        style:\n            (optional) A TableStyle object defining the table's appearance.\n            Defaults to NoBorderScreenStyle.\n        header_defs:\n            (optional) Column definitions for the header row. If not provided,\n            defaults to column definitions generated from header_cols.\n        col_defs:\n            (optional) Column definitions for the rest of the table rows. Only\n            required for styles that have an alignment character (e.g.,\n            Markdown). If not provided, uses the same as header_defs.\n        table_width:\n            (optional) Desired total width of the table. Will be automatically\n            calculated if not provided. Defaults to 0.\n        lazy_end:\n            (optional) If True, omits the right border of the table. Defaults\n            to True.\n\n    Behavior:\n        - If header_defs is not provided, generates default column definitions from header_cols.\n        - If col_defs is not provided, uses a copy of header_defs.\n        - Adjusts column definitions to fit the specified or calculated table width.\n        - Renders the top border if the style includes one.\n        - Renders the header row with the specified header definitions.\n        - Renders the bottom border (separator between header and data rows).\n        - For styles with alignment characters (e.g., Markdown), uses col_defs to determine\n          column alignment indicators in the separator line.\n\n    Returns:\n        A formatted string representing the table header, including top border,\n        header row, and header separator line as defined by the style.\n    \"\"\"\n    if not table_width and style.terminal_style:\n        table_width = get_term_width()\n\n    _header_defs = _get_adjusted_col_defs(\n        all_rows=[header_cols],\n        style=style,\n        col_defs=header_defs,\n        table_width=table_width,\n    )\n\n    if not col_defs:\n        _col_defs = _header_defs.copy()\n    elif isinstance(col_defs, ColDefList):\n        _col_defs = col_defs\n    else:\n        _col_defs = ColDefList(col_defs)\n\n    lazy_end = lazy_end and style.allow_lazy_header\n    padding_width = 2 * style.cell_padding\n\n    lines = []\n    if style.top_border:\n        line = str(style.header_top_line)\n        delim = str(style.header_top_delimiter)\n        left = str(style.header_top_left)\n        right = line if lazy_end else str(style.header_top_right)\n        border_lines = [line * (col.width + padding_width) for col in _col_defs]\n        border = delim.join(border_lines)\n        border = left + border + right\n        lines.append(border)\n\n    headers = _get_table_row(\n        values=header_cols,\n        style=style,\n        col_defs=_header_defs,\n        table_width=table_width,\n        lazy_end=lazy_end,\n        is_header=True,\n    )\n    lines.append(headers)\n\n    line = str(style.header_bottom_line)\n    delim = str(style.header_bottom_delimiter)\n    left = str(style.header_bottom_left)\n    right = line if lazy_end else str(style.header_bottom_right)\n    border_lines = []\n    for col_idx in range(len(header_cols)):\n        header_def = _header_defs[col_idx]\n        if not style.align_char:\n            h_line = line * (header_def.width + padding_width)\n        else:\n            col_def = None\n            if col_idx &lt; len(_col_defs):\n                col_def = _col_defs[col_idx]\n            h_line = line * header_def.width\n            if col_def and col_def.align == \"^\":\n                h_line = str(style.align_char) + h_line + str(style.align_char)\n            elif col_def and col_def.align == \"&gt;\":\n                h_line = \" \" + h_line + str(style.align_char)\n            else:\n                h_line = \" \" + h_line + \" \"\n        border_lines.append(h_line)\n    border = delim.join(border_lines)\n    border = left + border + right\n    lines.append(border)\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"references/text_styles/","title":"Text Styles","text":""},{"location":"references/text_styles/#craftable.styles.NoBorderScreenStyle","title":"<code>craftable.styles.NoBorderScreenStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> <p>Minimal, whitespace-delimited with a simple header separator.</p> Source code in <code>src/craftable/styles/no_border_screen_style.py</code> <pre><code>class NoBorderScreenStyle(TableStyle):\n    \"\"\"Minimal, whitespace-delimited with a simple header separator.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.top_border = False\n        self.bottom_border = False\n        self.header_left = \"\"\n        self.header_right = \"\"\n        self.header_bottom_left = \"\"\n        self.header_bottom_right = \"\"\n        self.values_left = \"\"\n        self.values_right = \"\"\n        self.values_bottom_left = \"\"\n        self.values_bottom_right = \"\"\n        self.row_separator_line = \"\u25e6\"\n        self.row_separator_left = \"\"\n        self.row_separator_right = \"\"\n</code></pre>"},{"location":"references/text_styles/#craftable.styles.BasicScreenStyle","title":"<code>craftable.styles.BasicScreenStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> <p>Classic box drawing with Unicode characters (\u2502 \u2500 \u250c \u2510 \u2514 \u2518 \u251c \u2524 \u252c \u2534 \u253c).</p> Source code in <code>src/craftable/styles/basic_screen_style.py</code> <pre><code>class BasicScreenStyle(TableStyle):\n    \"\"\"Classic box drawing with Unicode characters (\u2502 \u2500 \u250c \u2510 \u2514 \u2518 \u251c \u2524 \u252c \u2534 \u253c).\"\"\"\n\n    pass\n</code></pre>"},{"location":"references/text_styles/#craftable.styles.RoundedBorderScreenStyle","title":"<code>craftable.styles.RoundedBorderScreenStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> <p>Rounded corners for a softer look (\u256d \u256e \u2570 \u256f \u2502 \u2500).</p> Source code in <code>src/craftable/styles/rounded_border_screen_style.py</code> <pre><code>class RoundedBorderScreenStyle(TableStyle):\n    \"\"\"Rounded corners for a softer look (\u256d \u256e \u2570 \u256f \u2502 \u2500).\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.header_top_left = BoxChars.SINGLE_ARC_DOWN_AND_RIGHT\n        self.header_top_right = BoxChars.SINGLE_ARC_DOWN_AND_LEFT\n        self.no_header_top_left = BoxChars.SINGLE_ARC_DOWN_AND_RIGHT\n        self.no_header_top_right = BoxChars.SINGLE_ARC_DOWN_AND_LEFT\n        self.values_bottom_left = BoxChars.SINGLE_ARC_UP_AND_RIGHT\n        self.values_bottom_right = BoxChars.SINGLE_ARC_UP_AND_LEFT\n</code></pre>"},{"location":"references/text_styles/#craftable.styles.MarkdownStyle","title":"<code>craftable.styles.MarkdownStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> <p>GitHub-flavored Markdown tables for documentation.</p> Source code in <code>src/craftable/styles/markdown_style.py</code> <pre><code>class MarkdownStyle(TableStyle):\n    \"\"\"GitHub-flavored Markdown tables for documentation.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.top_border = False\n        self.bottom_border = False\n        self.terminal_style = False\n        self.allow_lazy_header = False\n        self.force_header = True\n        self.align_char = \":\"\n\n        self.min_width = 3\n\n        self.header_delimiter = \"|\"\n        self.header_left = \"|\"\n        self.header_right = \"|\"\n\n        self.header_bottom_line = \"-\"\n        self.header_bottom_delimiter = \"|\"\n        self.header_bottom_left = \"|\"\n        self.header_bottom_right = \"|\"\n\n        self.values_delimiter = \"|\"\n        self.values_left = \"|\"\n        self.values_right = \"|\"\n\n        self.row_separator_line = \"\"\n        self.row_separator_delimiter = \"\"\n        self.row_separator_left = \"\"\n        self.row_separator_right = \"\"\n</code></pre>"},{"location":"references/text_styles/#craftable.styles.ASCIIStyle","title":"<code>craftable.styles.ASCIIStyle</code>","text":"<p>               Bases: <code>TableStyle</code></p> <p>ASCII-only style for plain terminals and logs (uses + - |).</p> Source code in <code>src/craftable/styles/ascii_style.py</code> <pre><code>class ASCIIStyle(TableStyle):\n    \"\"\"ASCII-only style for plain terminals and logs (uses + - |).\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.terminal_style = False\n\n        # Outer borders\n        self.top_border = True\n        self.bottom_border = True\n\n        # Header borders\n        self.header_top_line = \"-\"\n        self.header_top_delimiter = \"+\"\n        self.header_top_left = \"+\"\n        self.header_top_right = \"+\"\n\n        self.header_delimiter = \"|\"\n        self.header_left = \"|\"\n        self.header_right = \"|\"\n\n        self.header_bottom_line = \"-\"\n        self.header_bottom_delimiter = \"+\"\n        self.header_bottom_left = \"+\"\n        self.header_bottom_right = \"+\"\n\n        # Data borders\n        self.values_delimiter = \"|\"\n        self.values_left = \"|\"\n        self.values_right = \"|\"\n\n        self.values_bottom_line = \"-\"\n        self.values_bottom_delimiter = \"+\"\n        self.values_bottom_left = \"+\"\n        self.values_bottom_right = \"+\"\n\n        # Row separator\n        self.row_separator_line = \"-\"\n        self.row_separator_left = \"|\"\n        self.row_separator_right = \"|\"\n</code></pre>"},{"location":"references/text_styles/#craftable.styles.TableStyle","title":"<code>craftable.styles.TableStyle</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for table styles.</p> <p>Defines all the visual attributes that control how a table is rendered, including borders, delimiters, padding, and special characters.</p> Source code in <code>src/craftable/styles/table_style.py</code> <pre><code>class TableStyle(ABC):\n    \"\"\"Abstract base class for table styles.\n\n    Defines all the visual attributes that control how a table is rendered,\n    including borders, delimiters, padding, and special characters.\n    \"\"\"\n\n    def __init__(self):\n        self.top_border = True\n        self.bottom_border = True\n        self.terminal_style = True\n        self.string_output = True  # False for binary formats (DOCX/XLSX/ODF/RTF)\n        self.allow_lazy_header = True\n        self.force_header = False\n        self.align_char = None\n\n        self.cell_padding = 1\n        self.min_width = 1\n\n        self.no_header_top_line = BoxChars.SINGLE_HORIZONTAL\n        self.no_header_top_delimiter = BoxChars.SINGLE_DOWN_AND_HORIZONTAL\n        self.no_header_top_left = BoxChars.SINGLE_DOWN_AND_RIGHT\n        self.no_header_top_right = BoxChars.SINGLE_DOWN_AND_LEFT\n\n        self.header_top_line = BoxChars.SINGLE_HORIZONTAL\n        self.header_top_delimiter = BoxChars.SINGLE_DOWN_AND_HORIZONTAL\n        self.header_top_left = BoxChars.SINGLE_DOWN_AND_RIGHT\n        self.header_top_right = BoxChars.SINGLE_DOWN_AND_LEFT\n\n        self.header_delimiter = BoxChars.SINGLE_VERTICAL\n        self.header_left = BoxChars.SINGLE_VERTICAL\n        self.header_right = BoxChars.SINGLE_VERTICAL\n\n        self.header_bottom_line = BoxChars.SINGLE_HORIZONTAL\n        self.header_bottom_delimiter = BoxChars.SINGLE_VERTICAL_AND_HORIZONTAL\n        self.header_bottom_left = BoxChars.SINGLE_VERTICAL_AND_RIGHT\n        self.header_bottom_right = BoxChars.SINGLE_VERTICAL_AND_LEFT\n\n        self.values_delimiter = BoxChars.SINGLE_VERTICAL\n        self.values_left = BoxChars.SINGLE_VERTICAL\n        self.values_right = BoxChars.SINGLE_VERTICAL\n\n        self.values_bottom_line = BoxChars.SINGLE_HORIZONTAL\n        self.values_bottom_delimiter = BoxChars.SINGLE_UP_AND_HORIZONTAL\n        self.values_bottom_left = BoxChars.SINGLE_UP_AND_RIGHT\n        self.values_bottom_right = BoxChars.SINGLE_UP_AND_LEFT\n\n        self.row_separator_line = \"\u25e6\"\n        self.row_separator_delimiter = BoxChars.SINGLE_VERTICAL\n        self.row_separator_left = BoxChars.SINGLE_VERTICAL\n        self.row_separator_right = BoxChars.SINGLE_VERTICAL\n</code></pre>"},{"location":"references/text_styles/#craftable.styles.BoxChars","title":"<code>craftable.styles.BoxChars</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Unicode box drawing characters</p> <p>Naming convention (normalized for consistency):</p> <ul> <li>SINGLE_* : thin single lines (Unicode: \"LIGHT\")</li> <li>HEAVY_* : thick single lines (Unicode: \"HEAVY\")</li> <li>DOUBLE_* : parallel double lines (Unicode: \"DOUBLE\")</li> <li>Mixed lines use pattern: WEIGHT_DIR_AND_WEIGHT_DIR</li> </ul> Source code in <code>src/craftable/styles/box_chars.py</code> <pre><code>class BoxChars(Enum):\n    \"\"\"Unicode box drawing characters\n\n    Naming convention (normalized for consistency):\n\n    - SINGLE_* : thin single lines (Unicode: \"LIGHT\")\n    - HEAVY_* : thick single lines (Unicode: \"HEAVY\")\n    - DOUBLE_* : parallel double lines (Unicode: \"DOUBLE\")\n    - Mixed lines use pattern: WEIGHT_DIR_AND_WEIGHT_DIR\n    \"\"\"\n\n    # SINGLE (thin single-line) characters\n    # BOX DRAWINGS LIGHT HORIZONTAL\n    SINGLE_HORIZONTAL = \"\\u2500\"  # \u2500\n    # BOX DRAWINGS LIGHT VERTICAL\n    SINGLE_VERTICAL = \"\\u2502\"  # \u2502\n    # BOX DRAWINGS LIGHT DOWN AND RIGHT\n    SINGLE_DOWN_AND_RIGHT = \"\\u250c\"  # \u250c\n    # BOX DRAWINGS LIGHT DOWN AND LEFT\n    SINGLE_DOWN_AND_LEFT = \"\\u2510\"  # \u2510\n    # BOX DRAWINGS LIGHT UP AND RIGHT\n    SINGLE_UP_AND_RIGHT = \"\\u2514\"  # \u2514\n    # BOX DRAWINGS LIGHT UP AND LEFT\n    SINGLE_UP_AND_LEFT = \"\\u2518\"  # \u2518\n    # BOX DRAWINGS LIGHT VERTICAL AND RIGHT\n    SINGLE_VERTICAL_AND_RIGHT = \"\\u251c\"  # \u251c\n    # BOX DRAWINGS LIGHT VERTICAL AND LEFT\n    SINGLE_VERTICAL_AND_LEFT = \"\\u2524\"  # \u2524\n    # BOX DRAWINGS LIGHT DOWN AND HORIZONTAL\n    SINGLE_DOWN_AND_HORIZONTAL = \"\\u252c\"  # \u252c\n    # BOX DRAWINGS LIGHT UP AND HORIZONTAL\n    SINGLE_UP_AND_HORIZONTAL = \"\\u2534\"  # \u2534\n    # BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL\n    SINGLE_VERTICAL_AND_HORIZONTAL = \"\\u253c\"  # \u253c\n    # BOX DRAWINGS LIGHT DOUBLE DASH HORIZONTAL\n    SINGLE_DOUBLE_DASH_HORIZONTAL = \"\\u254c\"  # \u254c\n    # BOX DRAWINGS LIGHT DOUBLE DASH VERTICAL\n    SINGLE_DOUBLE_DASH_VERTICAL = \"\\u254e\"  # \u254e\n\n    # ARC characters\n    # BOX DRAWINGS LIGHT ARC DOWN AND RIGHT\n    SINGLE_ARC_DOWN_AND_RIGHT = \"\\u256d\"  # \u256d\n    # BOX DRAWINGS LIGHT ARC DOWN AND LEFT\n    SINGLE_ARC_DOWN_AND_LEFT = \"\\u256e\"  # \u256e\n    # BOX DRAWINGS LIGHT ARC UP AND LEFT\n    SINGLE_ARC_UP_AND_LEFT = \"\\u256f\"  # \u256f\n    # BOX DRAWINGS LIGHT ARC UP AND RIGHT\n    SINGLE_ARC_UP_AND_RIGHT = \"\\u2570\"  # \u2570\n\n    # HEAVY (thick single-line) characters\n    # BOX DRAWINGS HEAVY HORIZONTAL\n    HEAVY_HORIZONTAL = \"\\u2501\"  # \u2501\n    # BOX DRAWINGS HEAVY VERTICAL\n    HEAVY_VERTICAL = \"\\u2503\"  # \u2503\n    # BOX DRAWINGS HEAVY DOWN AND RIGHT\n    HEAVY_DOWN_AND_RIGHT = \"\\u250f\"  # \u250f\n    # BOX DRAWINGS HEAVY DOWN AND LEFT\n    HEAVY_DOWN_AND_LEFT = \"\\u2513\"  # \u2513\n    # BOX DRAWINGS HEAVY UP AND RIGHT\n    HEAVY_UP_AND_RIGHT = \"\\u2517\"  # \u2517\n    # BOX DRAWINGS HEAVY UP AND LEFT\n    HEAVY_UP_AND_LEFT = \"\\u251b\"  # \u251b\n    # BOX DRAWINGS HEAVY VERTICAL AND RIGHT\n    HEAVY_VERTICAL_AND_RIGHT = \"\\u2523\"  # \u2523\n    # BOX DRAWINGS HEAVY VERTICAL AND LEFT\n    HEAVY_VERTICAL_AND_LEFT = \"\\u252b\"  # \u252b\n    # BOX DRAWINGS HEAVY DOWN AND HORIZONTAL\n    HEAVY_DOWN_AND_HORIZONTAL = \"\\u2533\"  # \u2533\n    # BOX DRAWINGS HEAVY_UP_AND_HORIZONTAL (Unicode: BOX DRAWINGS HEAVY UP AND HORIZONTAL)\n    HEAVY_UP_AND_HORIZONTAL = \"\\u253b\"  # \u253b\n    # BOX DRAWINGS HEAVY VERTICAL AND HORIZONTAL\n    HEAVY_VERTICAL_AND_HORIZONTAL = \"\\u254b\"  # \u254b\n    # BOX DRAWINGS HEAVY DOUBLE DASH HORIZONTAL\n    HEAVY_DOUBLE_DASH_HORIZONTAL = \"\\u254d\"  # \u254d\n    # BOX DRAWINGS HEAVY DOUBLE DASH VERTICAL\n    HEAVY_DOUBLE_DASH_VERTICAL = \"\\u254f\"  # \u254f\n\n    # DOUBLE (parallel line) characters\n    # BOX DRAWINGS DOUBLE HORIZONTAL\n    DOUBLE_HORIZONTAL = \"\\u2550\"  # \u2550\n    # BOX DRAWINGS DOUBLE VERTICAL\n    DOUBLE_VERTICAL = \"\\u2551\"  # \u2551\n    # BOX DRAWINGS DOUBLE DOWN AND RIGHT\n    DOUBLE_DOWN_AND_RIGHT = \"\\u2554\"  # \u2554\n    # BOX DRAWINGS DOUBLE DOWN AND LEFT\n    DOUBLE_DOWN_AND_LEFT = \"\\u2557\"  # \u2557\n    # BOX DRAWINGS DOUBLE UP AND RIGHT\n    DOUBLE_UP_AND_RIGHT = \"\\u255a\"  # \u255a\n    # BOX DRAWINGS DOUBLE UP AND LEFT\n    DOUBLE_UP_AND_LEFT = \"\\u255d\"  # \u255d\n    # BOX DRAWINGS DOUBLE VERTICAL AND RIGHT\n    DOUBLE_VERTICAL_AND_RIGHT = \"\\u2560\"  # \u2560\n    # BOX DRAWINGS DOUBLE VERTICAL AND LEFT\n    DOUBLE_VERTICAL_AND_LEFT = \"\\u2563\"  # \u2563\n    # BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL\n    DOUBLE_DOWN_AND_HORIZONTAL = \"\\u2566\"  # \u2566\n    # BOX DRAWINGS DOUBLE UP AND HORIZONTAL\n    DOUBLE_UP_AND_HORIZONTAL = \"\\u2569\"  # \u2569\n    # BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL\n    DOUBLE_VERTICAL_AND_HORIZONTAL = \"\\u256c\"  # \u256c\n\n    # MIXED single and double line characters\n    # BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE\n    DOUBLE_RIGHT_AND_SINGLE_DOWN = \"\\u2552\"  # \u2552\n    # BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE\n    SINGLE_RIGHT_AND_DOUBLE_DOWN = \"\\u2553\"  # \u2553\n    # BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE\n    DOUBLE_LEFT_AND_SINGLE_DOWN = \"\\u2555\"  # \u2555\n    # BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE\n    SINGLE_LEFT_AND_DOUBLE_DOWN = \"\\u2556\"  # \u2556\n    # BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE\n    DOUBLE_RIGHT_AND_SINGLE_UP = \"\\u2558\"  # \u2558\n    # BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE\n    SINGLE_RIGHT_AND_DOUBLE_UP = \"\\u2559\"  # \u2559\n    # BOX DRAWINGS UP SINGLE AND LEFT DOUBLE\n    DOUBLE_LEFT_AND_SINGLE_UP = \"\\u255b\"  # \u255b\n    # BOX DRAWINGS UP DOUBLE AND LEFT SINGLE\n    SINGLE_LEFT_AND_DOUBLE_UP = \"\\u255c\"  # \u255c\n    # BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE\n    DOUBLE_VERTICAL_AND_SINGLE_RIGHT = \"\\u255e\"  # \u255e\n    # BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE\n    SINGLE_VERTICAL_AND_DOUBLE_RIGHT = \"\\u255f\"  # \u255f\n    # BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE\n    DOUBLE_VERTICAL_AND_SINGLE_LEFT = \"\\u2561\"  # \u2561\n    # BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE\n    SINGLE_VERTICAL_AND_DOUBLE_LEFT = \"\\u2562\"  # \u2562\n    # BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE\n    DOUBLE_HORIZONTAL_AND_SINGLE_DOWN = \"\\u2564\"  # \u2564\n    # BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE\n    SINGLE_HORIZONTAL_AND_DOUBLE_DOWN = \"\\u2565\"  # \u2565\n    # BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE\n    DOUBLE_HORIZONTAL_AND_SINGLE_UP = \"\\u2567\"  # \u2567\n    # BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE\n    SINGLE_HORIZONTAL_AND_DOUBLE_UP = \"\\u2568\"  # \u2568\n    # BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE\n    DOUBLE_HORIZONTAL_AND_SINGLE_VERTICAL = \"\\u256a\"  # \u256a\n    # BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE\n    SINGLE_HORIZONTAL_AND_DOUBLE_VERTICAL = \"\\u256b\"  # \u256b\n\n    def __str__(self):\n        return self.value\n\n    def __repr__(self):\n        return self.value\n</code></pre>"}]}
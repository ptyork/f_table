## Advanced: Preprocessors and Postprocessors

For advanced scenarios, f_table supports per-column callbacks to transform values
before formatting (preprocessors) and to decorate text after all sizing and wrapping
has been performed (postprocessors).

- Preprocessors: list of callables `fn(value) -> value`, applied before width
  computation and before `ColDef.format`. Use these to normalize or coerce types,
  clamp ranges, or derive display strings that should influence column width.

- Postprocessors: list of callables `fn(original_value, text) -> str`, applied after
  `ColDef.format_text` and after any wrapping. Use these to add non-width-affecting
  decorations like ANSI color codes or styling markup. It is assumed they won’t
  change the displayed width of text.

Usage example:

```python
from f_table import get_table

rows = [["alice", 123.456], ["bob", 7.5]]
col_defs = ["<10", ">8.2f"]

def name_pre(val):
    # Capitalize names before width calc/formatting
    return str(val).capitalize()

def number_post(original, text):
    # Add a simple decoration after sizing/wrapping
    return f"[{text}]"

table = get_table(
    rows,
    header_row=["Name", "Amount"],
    col_defs=col_defs,
    preprocessors=[name_pre, None],
    postprocessors=[None, number_post],
)
print(table)
```

Notes:

- The lists are column-indexed; you can pass `None` for columns with no callback.
- If a list is shorter than the number of columns, missing entries are ignored.
- Errors inside callbacks are caught and ignored for that cell; rendering continues.
- Postprocessors run after width and wrapping decisions, so don’t influence layout.
